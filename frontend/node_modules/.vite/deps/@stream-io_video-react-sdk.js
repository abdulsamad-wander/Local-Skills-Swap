import {
  AudioSettingsRequestDefaultDeviceEnum,
  AudioSettingsResponseDefaultDeviceEnum,
  Call,
  CallRecordingFailedEventRecordingTypeEnum,
  CallRecordingReadyEventRecordingTypeEnum,
  CallRecordingStartedEventRecordingTypeEnum,
  CallRecordingStoppedEventRecordingTypeEnum,
  CallState,
  CallType,
  CallTypes,
  CallingState,
  CameraManager,
  CameraManagerState,
  CreateDeviceRequestPushProviderEnum,
  DebounceType,
  DeviceManager,
  DeviceManagerState,
  DynascaleManager,
  ErrorFromResponse,
  FrameRecordingSettingsRequestModeEnum,
  FrameRecordingSettingsRequestQualityEnum,
  FrameRecordingSettingsResponseModeEnum,
  IndividualRecordingSettingsRequestModeEnum,
  IndividualRecordingSettingsResponseModeEnum,
  IngressAudioEncodingOptionsRequestChannelsEnum,
  IngressSourceRequestFpsEnum,
  IngressVideoLayerRequestCodecEnum,
  LayoutSettingsRequestNameEnum,
  LogLevelEnum,
  MicrophoneManager,
  MicrophoneManagerState,
  NoiseCancellationSettingsModeEnum,
  OwnCapability,
  RNSpeechDetector,
  RTMPBroadcastRequestQualityEnum,
  RTMPSettingsRequestQualityEnum,
  RawRecordingSettingsRequestModeEnum,
  RawRecordingSettingsResponseModeEnum,
  RecordSettingsRequestModeEnum,
  RecordSettingsRequestQualityEnum,
  Restricted,
  ScreenShareManager,
  ScreenShareState,
  SfuJoinError,
  SpeakerManager,
  SpeakerState,
  StartClosedCaptionsRequestLanguageEnum,
  StartTranscriptionRequestLanguageEnum,
  StreamCallProvider,
  StreamI18n,
  StreamI18nProvider,
  StreamSfuClient,
  StreamVideoClient,
  StreamVideoProvider,
  StreamVideoReadOnlyStateStore,
  StreamVideoWriteableStateStore,
  TranscriptionSettingsRequestClosedCaptionModeEnum,
  TranscriptionSettingsRequestLanguageEnum,
  TranscriptionSettingsRequestModeEnum,
  TranscriptionSettingsResponseClosedCaptionModeEnum,
  TranscriptionSettingsResponseLanguageEnum,
  TranscriptionSettingsResponseModeEnum,
  VideoSettingsRequestCameraFacingEnum,
  VideoSettingsResponseCameraFacingEnum,
  ViewportTracker,
  VisibilityState,
  browsers,
  checkIfAudioOutputChangeSupported,
  combineComparators,
  conditional,
  createSoundDetector,
  defaultSortPreset,
  defaultTranslationFunction,
  descending,
  deviceIds$,
  disposeOfMediaStream,
  dominantSpeaker,
  events,
  getAudioBrowserPermission,
  getAudioDevices,
  getAudioOutputDevices,
  getAudioStream,
  getClientDetails,
  getDeviceState,
  getScreenShareStream,
  getSdkInfo,
  getVideoBrowserPermission,
  getVideoDevices,
  getVideoStream,
  getWebRTCInfo,
  hasAudio,
  hasPausedTrack,
  hasScreenShare,
  hasScreenShareAudio,
  hasVideo,
  humanize,
  isPinned,
  livestreamOrAudioRoomSortPreset,
  logToConsole,
  models,
  name,
  noopComparator,
  paginatedLayoutSortPreset,
  pinned,
  publishingAudio,
  publishingVideo,
  reactionType,
  resolveDeviceId,
  role,
  rxUtils,
  screenSharing,
  setDeviceInfo,
  setOSInfo,
  setPowerState,
  setSdkInfo,
  setThermalState,
  setWebRTCInfo,
  speakerLayoutSortPreset,
  speaking,
  useCall,
  useCallStateHooks,
  useCalls,
  useConnectedUser,
  useEffectEvent,
  useI18n,
  useObservableValue,
  useStore,
  useStreamVideoClient,
  useToggleCallRecording,
  videoLoggerSystem,
  withParticipantSource
} from "./chunk-NLTDV5XU.js";
import "./chunk-LMRBY6JE.js";
import {
  FloatingArrow,
  FloatingFocusManager,
  FloatingList,
  FloatingOverlay,
  FloatingPortal,
  arrow,
  autoUpdate,
  flip,
  offset,
  shift,
  size,
  useClick,
  useDismiss,
  useFloating,
  useHover,
  useInteractions,
  useListItem,
  useListNavigation,
  useRole,
  useTypeahead
} from "./chunk-GKOMEASY.js";
import {
  clsx_default
} from "./chunk-IABRG3G4.js";
import {
  AxiosError
} from "./chunk-BQTSAFSW.js";
import "./chunk-PBX5ABKV.js";
import {
  require_jsx_runtime
} from "./chunk-4UTF2CDO.js";
import {
  require_react
} from "./chunk-BXEBRY3I.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@stream-io/video-react-sdk/dist/index.es.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());
var Audio = ({ participant, trackType = "audioTrack", ...rest }) => {
  const call = useCall();
  const [audioElement, setAudioElement] = (0, import_react.useState)(null);
  const { userId, sessionId } = participant;
  (0, import_react.useEffect)(() => {
    if (!call || !audioElement)
      return;
    const cleanup = call.bindAudioElement(audioElement, sessionId, trackType);
    return () => {
      cleanup?.();
    };
  }, [call, sessionId, audioElement, trackType]);
  return (0, import_jsx_runtime.jsx)("audio", { autoPlay: true, ...rest, ref: setAudioElement, "data-user-id": userId, "data-session-id": sessionId, "data-track-type": trackType });
};
Audio.displayName = "Audio";
var ParticipantsAudio = (props) => {
  const { participants, audioProps } = props;
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: participants.map((participant) => {
    if (participant.isLocalParticipant)
      return null;
    const { audioStream, screenShareAudioStream, sessionId } = participant;
    const hasAudioTrack = hasAudio(participant);
    const audioTrackElement = hasAudioTrack && audioStream && (0, import_jsx_runtime.jsx)(Audio, { ...audioProps, trackType: "audioTrack", participant });
    const hasScreenShareAudioTrack = hasScreenShareAudio(participant);
    const screenShareAudioTrackElement = hasScreenShareAudioTrack && screenShareAudioStream && (0, import_jsx_runtime.jsx)(Audio, { ...audioProps, trackType: "screenShareAudioTrack", participant });
    return (0, import_jsx_runtime.jsxs)(import_react.Fragment, { children: [audioTrackElement, screenShareAudioTrackElement] }, sessionId);
  }) });
};
ParticipantsAudio.displayName = "ParticipantsAudio";
var ParticipantViewContext = (0, import_react.createContext)(void 0);
var useParticipantViewContext = () => (0, import_react.useContext)(ParticipantViewContext);
var useFloatingUIPreset = ({ middleware = [], placement, strategy, offset: offsetInPx = 10 }) => {
  const { refs, x, y, update, elements: { domReference, floating }, context } = useFloating({
    placement,
    strategy,
    middleware: [
      offset(offsetInPx),
      shift(),
      flip(),
      size({
        padding: 10,
        apply: ({ availableHeight, elements }) => {
          Object.assign(elements.floating.style, {
            maxHeight: `${availableHeight}px`
          });
        }
      }),
      ...middleware
    ]
  });
  (0, import_react.useEffect)(() => {
    if (!domReference || !floating)
      return;
    const cleanup = autoUpdate(domReference, floating, update);
    return () => cleanup();
  }, [domReference, floating, update]);
  return { refs, x, y, domReference, floating, strategy, context };
};
var defaultDevice = "default";
var usePersistedDevicePreferences = (key = "@stream-io/device-preferences") => {
  const { useCallSettings, useCallCallingState, useMicrophoneState, useCameraState, useSpeakerState } = useCallStateHooks();
  const settings = useCallSettings();
  const callingState = useCallCallingState();
  const microphoneState = useMicrophoneState();
  const cameraState = useCameraState();
  const speakerState = useSpeakerState();
  const [applyingState, setApplyingState] = (0, import_react.useState)("idle");
  const call = useCall();
  const deferredCallRef = (0, import_react.useRef)(null);
  if (call && deferredCallRef.current !== call) {
    call.camera.deferServerDefaults = true;
    call.microphone.deferServerDefaults = true;
    deferredCallRef.current = call;
  }
  (0, import_react.useEffect)(() => {
    return () => {
      const currentCall = deferredCallRef.current;
      if (currentCall) {
        currentCall.camera.deferServerDefaults = false;
        currentCall.microphone.deferServerDefaults = false;
        deferredCallRef.current = null;
      }
    };
  }, [call]);
  const cameraDevices = settings?.video?.enabled ? cameraState.devices : false;
  (0, import_react.useEffect)(function apply() {
    if (callingState === CallingState.LEFT || microphoneState.devices.length === 0 || Array.isArray(cameraDevices) && cameraDevices.length === 0 || speakerState.devices.length === 0 || !settings || applyingState !== "idle") {
      return;
    }
    setApplyingState("applying");
    (async () => {
      const { audio, video } = settings;
      for (const [deviceKey, state, defaultMuted, enabledInCallType] of [
        ["microphone", microphoneState, !audio.mic_default_on, true],
        ["camera", cameraState, !video.camera_default_on, video.enabled],
        ["speaker", speakerState, false, true]
      ]) {
        const preferences = parseLocalDevicePreferences(key);
        const preference = preferences[deviceKey];
        const manager = state[deviceKey];
        const applyPromise = preference ? applyLocalDevicePreference(manager, [preference].flat(), deviceKey === "camera" ? cameraDevices || [] : state.devices, enabledInCallType) : applyMutedState(manager, defaultMuted, enabledInCallType);
        await applyPromise.catch((err) => {
          console.warn(`Failed to apply ${deviceKey} device preferences`, err);
        });
      }
    })().finally(() => setApplyingState((state) => state === "applying" ? "applied" : state));
  }, [
    applyingState,
    callingState,
    cameraState,
    cameraDevices,
    key,
    microphoneState,
    microphoneState.devices,
    settings,
    speakerState,
    speakerState.devices
  ]);
  (0, import_react.useEffect)(function persist() {
    if (callingState === CallingState.LEFT || applyingState !== "applied") {
      return;
    }
    for (const [deviceKey, devices, selectedDevice, isMute] of [
      [
        "camera",
        cameraDevices || [],
        cameraState.selectedDevice,
        cameraState.isMute
      ],
      [
        "microphone",
        microphoneState.devices,
        microphoneState.selectedDevice,
        microphoneState.isMute
      ],
      [
        "speaker",
        speakerState.devices,
        speakerState.selectedDevice,
        speakerState.isMute
      ]
    ]) {
      try {
        patchLocalDevicePreference(key, deviceKey, {
          devices,
          selectedDevice,
          isMute
        });
      } catch (err) {
        console.warn(`Failed to save ${deviceKey} device preferences`, err);
      }
    }
  }, [
    applyingState,
    callingState,
    cameraDevices,
    cameraState.isMute,
    cameraState.selectedDevice,
    key,
    microphoneState.devices,
    microphoneState.isMute,
    microphoneState.selectedDevice,
    speakerState.devices,
    speakerState.isMute,
    speakerState.selectedDevice
  ]);
};
var parseLocalDevicePreferences = (key) => {
  const preferencesStr = window.localStorage.getItem(key);
  let preferences = {};
  if (preferencesStr) {
    try {
      preferences = JSON.parse(preferencesStr);
      if (Object.hasOwn(preferences, "mic")) {
        preferences.microphone = preferences.mic;
      }
    } catch {
    }
  }
  return preferences;
};
var patchLocalDevicePreference = (key, deviceKey, state) => {
  const preferences = parseLocalDevicePreferences(key);
  const nextPreference = getSelectedDevicePreference(state.devices, state.selectedDevice);
  const preferenceHistory = [preferences[deviceKey] ?? []].flat().filter((p) => p.selectedDeviceId !== nextPreference.selectedDeviceId && (p.selectedDeviceLabel === "" || p.selectedDeviceLabel !== nextPreference.selectedDeviceLabel));
  window.localStorage.setItem(key, JSON.stringify({
    ...preferences,
    mic: void 0,
    // for backwards compatibility
    [deviceKey]: [
      {
        ...nextPreference,
        muted: state.isMute
      },
      ...preferenceHistory
    ].slice(0, 3)
  }));
};
var applyLocalDevicePreference = async (manager, preference, devices, enabledInCallType) => {
  let muted;
  for (const p of preference) {
    muted ?? (muted = p.muted);
    if (p.selectedDeviceId === defaultDevice) {
      break;
    }
    const device = devices.find((d) => d.deviceId === p.selectedDeviceId) ?? devices.find((d) => d.label === p.selectedDeviceLabel);
    if (device) {
      if (!manager.state.selectedDevice) {
        await manager.select(device.deviceId);
      }
      muted = p.muted;
      break;
    }
  }
  if (typeof muted === "boolean") {
    await applyMutedState(manager, muted, enabledInCallType);
  }
};
var applyMutedState = async (manager, muted, enabledInCallType) => {
  if (enabledInCallType && !manager.state.status) {
    await manager[muted ? "disable" : "enable"]?.();
  }
};
var getSelectedDevicePreference = (devices, selectedDevice) => ({
  selectedDeviceId: selectedDevice || defaultDevice,
  selectedDeviceLabel: devices?.find((d) => d.deviceId === selectedDevice)?.label ?? ""
});
var SCROLL_THRESHOLD = 10;
var useVerticalScrollPosition = (scrollElement, threshold = SCROLL_THRESHOLD) => {
  const [scrollPosition, setScrollPosition] = (0, import_react.useState)(null);
  (0, import_react.useEffect)(() => {
    if (!scrollElement)
      return;
    const scrollHandler = () => {
      const element = scrollElement;
      const hasVerticalScrollbar = element.scrollHeight > element.clientHeight;
      if (!hasVerticalScrollbar)
        return setScrollPosition(null);
      const isAtTheTop = element.scrollTop <= threshold;
      if (isAtTheTop)
        return setScrollPosition("top");
      const isAtTheBottom = Math.abs(element.scrollHeight - element.scrollTop - element.clientHeight) <= threshold;
      if (isAtTheBottom)
        return setScrollPosition("bottom");
      setScrollPosition("between");
    };
    const resizeObserver = new ResizeObserver(scrollHandler);
    resizeObserver.observe(scrollElement);
    scrollElement.addEventListener("scroll", scrollHandler);
    return () => {
      scrollElement.removeEventListener("scroll", scrollHandler);
      resizeObserver.disconnect();
    };
  }, [scrollElement, threshold]);
  return scrollPosition;
};
var useHorizontalScrollPosition = (scrollElement, threshold = SCROLL_THRESHOLD) => {
  const [scrollPosition, setScrollPosition] = (0, import_react.useState)(null);
  (0, import_react.useEffect)(() => {
    if (!scrollElement)
      return;
    const scrollHandler = () => {
      const element = scrollElement;
      const hasHorizontalScrollbar = element.scrollWidth > element.clientWidth;
      if (!hasHorizontalScrollbar)
        return setScrollPosition(null);
      const isAtTheStart = element.scrollLeft <= threshold;
      if (isAtTheStart)
        return setScrollPosition("start");
      const isAtTheEnd = Math.abs(element.scrollWidth - element.scrollLeft - element.clientWidth) <= threshold;
      if (isAtTheEnd)
        return setScrollPosition("end");
      setScrollPosition("between");
    };
    const resizeObserver = new ResizeObserver(scrollHandler);
    resizeObserver.observe(scrollElement);
    scrollElement.addEventListener("scroll", scrollHandler);
    return () => {
      scrollElement.removeEventListener("scroll", scrollHandler);
      resizeObserver.disconnect();
    };
  }, [scrollElement, threshold]);
  return scrollPosition;
};
var useRequestPermission = (permission) => {
  const call = useCall();
  const { useHasPermissions } = useCallStateHooks();
  const hasPermission = useHasPermissions(permission);
  const [isAwaitingPermission, setIsAwaitingPermission] = (0, import_react.useState)(false);
  (0, import_react.useEffect)(() => {
    const reset = () => setIsAwaitingPermission(false);
    if (hasPermission)
      reset();
  }, [hasPermission]);
  const requestPermission = (0, import_react.useCallback)(async () => {
    if (hasPermission)
      return true;
    const canRequestPermission = !!call?.permissionsContext.canRequest(permission);
    if (isAwaitingPermission || !canRequestPermission)
      return false;
    setIsAwaitingPermission(true);
    try {
      await call?.requestPermissions({
        permissions: [permission]
      });
    } catch (error) {
      setIsAwaitingPermission(false);
      throw new Error(`requestPermission failed: ${error}`);
    }
    return false;
  }, [call, hasPermission, isAwaitingPermission, permission]);
  return {
    requestPermission,
    hasPermission,
    canRequestPermission: !!call?.permissionsContext.canRequest(permission),
    isAwaitingPermission
  };
};
function useDeviceList(devices, selectedDeviceId) {
  const { t } = useI18n();
  return (0, import_react.useMemo)(() => {
    let selectedDeviceInfo = null;
    let selectedIndex = null;
    const deviceList = devices.map((d, i) => {
      const isSelected = d.deviceId === selectedDeviceId;
      const device = { deviceId: d.deviceId, label: d.label, isSelected };
      if (isSelected) {
        selectedDeviceInfo = device;
        selectedIndex = i;
      }
      return device;
    });
    if (selectedDeviceInfo === null || selectedIndex === null) {
      const defaultDevice2 = {
        deviceId: "default",
        label: t("Default"),
        isSelected: true
      };
      selectedDeviceInfo = defaultDevice2;
      selectedIndex = 0;
      deviceList.unshift(defaultDevice2);
    }
    return { deviceList, selectedDeviceInfo, selectedIndex };
  }, [devices, selectedDeviceId, t]);
}
var isFullScreenBlurPlatformSupported = () => {
  if (typeof window === "undefined" || typeof OffscreenCanvas === "undefined" || typeof VideoFrame === "undefined" || !window.WebGL2RenderingContext) {
    return false;
  }
  try {
    const canvas = new OffscreenCanvas(1, 1);
    return !!canvas.getContext("webgl2", {
      alpha: false,
      antialias: false,
      desynchronized: true
    });
  } catch {
    return false;
  }
};
var useModeration = (options) => {
  const { duration = 5e3 } = options || {};
  const call = useCall();
  const timeoutRef = (0, import_react.useRef)(null);
  const processorRef = (0, import_react.useRef)(null);
  const unregisterRef = (0, import_react.useRef)(null);
  const blurModulePromise = (0, import_react.useRef)(null);
  const loadVideoFiltersWebModule = (0, import_react.useCallback)(() => {
    if (!blurModulePromise.current) {
      blurModulePromise.current = import("./index.es-XP3JRTWK.js").then((module) => module.FullScreenBlur).catch((error) => {
        console.error("[moderation] Failed to import blur module:", error);
        throw error;
      });
    }
    return blurModulePromise.current;
  }, []);
  const disableBlur = (0, import_react.useCallback)(() => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
    unregisterRef.current?.().catch((err) => console.error("[moderation] unregister error:", err));
    unregisterRef.current = null;
  }, []);
  const handleFallback = (0, import_react.useCallback)(async () => {
    try {
      await call?.camera.disable();
    } catch (error) {
      console.error("[moderation] Failed to disable camera:", error);
    }
  }, [call]);
  (0, import_react.useEffect)(() => {
    if (!call)
      return;
    return call.on("call.moderation_warning", async () => {
      try {
        await loadVideoFiltersWebModule();
      } catch (importErr) {
        console.error("[moderation] Failed to import blur module:", importErr);
      }
    });
  }, [call, loadVideoFiltersWebModule]);
  (0, import_react.useEffect)(() => {
    if (!call)
      return;
    return call.on("call.moderation_blur", async () => {
      if (unregisterRef.current)
        return;
      let FullScreenBlurClass;
      try {
        FullScreenBlurClass = await loadVideoFiltersWebModule();
      } catch (importErr) {
        console.error("[moderation] Failed to import blur module:", importErr);
        await handleFallback();
        return;
      }
      if (!isFullScreenBlurPlatformSupported()) {
        console.warn("[moderation] Blur not supported on this platform");
        await handleFallback();
        return;
      }
      const { unregister } = call.camera.registerFilter((inputStream) => {
        unregisterRef.current = unregister;
        const outputPromise = new Promise(async (resolve, reject) => {
          const [track] = inputStream.getVideoTracks();
          let processor;
          try {
            processor = new FullScreenBlurClass(track);
            processorRef.current = processor;
            const result = await processor.start();
            const output = new MediaStream([result]);
            resolve(output);
            if (duration > 0) {
              timeoutRef.current = setTimeout(disableBlur, duration);
            }
          } catch (error) {
            reject(error);
            console.error("[moderation] Processor init failed:", error);
            await unregisterRef.current?.();
            unregisterRef.current = null;
            processorRef.current = null;
            await handleFallback();
            return;
          }
        });
        return {
          output: outputPromise,
          stop: () => {
            if (processorRef.current) {
              processorRef.current.stop();
              processorRef.current = null;
            }
          }
        };
      });
    });
  }, [call, loadVideoFiltersWebModule, disableBlur, handleFallback, duration]);
  (0, import_react.useEffect)(() => disableBlur, [disableBlur]);
};
function useDragToScroll(element, options = {}) {
  const stateRef = (0, import_react.useRef)({
    isDragging: false,
    isPointerActive: false,
    prevX: 0,
    prevY: 0,
    velocityX: 0,
    velocityY: 0,
    rafId: 0,
    startX: 0,
    startY: 0
  });
  (0, import_react.useEffect)(() => {
    if (!element || !options.enabled)
      return;
    const { decay = 0.95, minVelocity = 0.5, dragThreshold = 5 } = options;
    const state = stateRef.current;
    const stopMomentum = () => {
      if (state.rafId) {
        cancelAnimationFrame(state.rafId);
        state.rafId = 0;
      }
      state.velocityX = 0;
      state.velocityY = 0;
    };
    const momentumStep = () => {
      state.velocityX *= decay;
      state.velocityY *= decay;
      element.scrollLeft -= state.velocityX;
      element.scrollTop -= state.velocityY;
      if (Math.abs(state.velocityX) < minVelocity && Math.abs(state.velocityY) < minVelocity) {
        state.rafId = 0;
        return;
      }
      state.rafId = requestAnimationFrame(momentumStep);
    };
    const onPointerDown = (e) => {
      if (e.pointerType !== "mouse")
        return;
      stopMomentum();
      state.isDragging = false;
      state.isPointerActive = true;
      state.prevX = e.clientX;
      state.prevY = e.clientY;
      state.startX = e.clientX;
      state.startY = e.clientY;
    };
    const onPointerMove = (e) => {
      if (e.pointerType !== "mouse")
        return;
      if (!state.isPointerActive)
        return;
      const dx = e.clientX - state.startX;
      const dy = e.clientY - state.startY;
      if (!state.isDragging && Math.hypot(dx, dy) > dragThreshold) {
        state.isDragging = true;
        e.preventDefault();
      }
      if (!state.isDragging)
        return;
      const moveDx = e.clientX - state.prevX;
      const moveDy = e.clientY - state.prevY;
      element.scrollLeft -= moveDx;
      element.scrollTop -= moveDy;
      state.velocityX = moveDx;
      state.velocityY = moveDy;
      state.prevX = e.clientX;
      state.prevY = e.clientY;
    };
    const onPointerUpOrCancel = () => {
      const wasDragging = state.isDragging;
      state.isDragging = false;
      state.isPointerActive = false;
      state.prevX = 0;
      state.prevY = 0;
      state.startX = 0;
      state.startY = 0;
      if (!wasDragging) {
        stopMomentum();
        return;
      }
      if (Math.hypot(state.velocityX, state.velocityY) < minVelocity) {
        stopMomentum();
        return;
      }
      state.rafId = requestAnimationFrame(momentumStep);
    };
    element.addEventListener("pointerdown", onPointerDown);
    element.addEventListener("pointermove", onPointerMove);
    window.addEventListener("pointerup", onPointerUpOrCancel);
    window.addEventListener("pointercancel", onPointerUpOrCancel);
    return () => {
      element.removeEventListener("pointerdown", onPointerDown);
      element.removeEventListener("pointermove", onPointerMove);
      window.removeEventListener("pointerup", onPointerUpOrCancel);
      window.removeEventListener("pointercancel", onPointerUpOrCancel);
      stopMomentum();
    };
  }, [element, options]);
}
var MenuVisualType;
(function(MenuVisualType2) {
  MenuVisualType2["PORTAL"] = "portal";
  MenuVisualType2["MENU"] = "menu";
})(MenuVisualType || (MenuVisualType = {}));
var MenuContext = (0, import_react.createContext)({});
var useMenuContext = () => {
  return (0, import_react.useContext)(MenuContext);
};
var MenuPortal = ({ children, refs }) => {
  const [portalRoot, setPortalRoot] = (0, import_react.useState)(null);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("div", { ref: setPortalRoot, className: "str-video__portal" }), (0, import_jsx_runtime.jsx)(FloatingOverlay, { children: (0, import_jsx_runtime.jsx)(FloatingPortal, { root: portalRoot, children: (0, import_jsx_runtime.jsx)("div", { className: "str-video__portal-content", ref: refs.setFloating, children }) }) })] });
};
var MenuToggle = ({ ToggleButton: ToggleButton5, placement = "top-start", strategy = "absolute", offset: offset2, visualType = MenuVisualType.MENU, children, onToggle }) => {
  const [menuShown, setMenuShown] = (0, import_react.useState)(false);
  const toggleHandler = (0, import_react.useRef)(onToggle);
  toggleHandler.current = onToggle;
  const { floating, domReference, refs, x, y } = useFloatingUIPreset({
    placement,
    strategy,
    offset: offset2
  });
  (0, import_react.useEffect)(() => {
    const parentDocument = domReference?.ownerDocument;
    const handleClick = (event) => {
      if (!floating && domReference?.contains(event.target)) {
        setMenuShown(true);
        toggleHandler.current?.(true);
      } else if (floating && !floating?.contains(event.target)) {
        setMenuShown(false);
        toggleHandler.current?.(false);
      }
    };
    const handleKeyDown = (event) => {
      if (event.key && // key can be undefined in some browsers
      event.key.toLowerCase() === "escape" && !event.altKey && !event.ctrlKey) {
        setMenuShown(false);
        toggleHandler.current?.(false);
      }
    };
    parentDocument?.addEventListener("click", handleClick, { capture: true });
    parentDocument?.addEventListener("keydown", handleKeyDown);
    return () => {
      parentDocument?.removeEventListener("click", handleClick, {
        capture: true
      });
      parentDocument?.removeEventListener("keydown", handleKeyDown);
    };
  }, [floating, domReference]);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [menuShown && (0, import_jsx_runtime.jsx)(MenuContext.Provider, { value: { close: () => setMenuShown(false) }, children: visualType === MenuVisualType.PORTAL ? (0, import_jsx_runtime.jsx)(MenuPortal, { refs, children }) : visualType === MenuVisualType.MENU ? (0, import_jsx_runtime.jsx)("div", { className: "str-video__menu-container", ref: refs.setFloating, style: {
    position: strategy,
    top: y ?? 0,
    left: x ?? 0,
    overflowY: "auto"
  }, role: "menu", children }) : null }), (0, import_jsx_runtime.jsx)(ToggleButton5, { menuShown, ref: refs.setReference })] });
};
var GenericMenu = ({ children, onItemClick }) => {
  const ref = (0, import_react.useRef)(null);
  return (0, import_jsx_runtime.jsx)("ul", { className: "str-video__generic-menu", ref, onClick: (e) => {
    if (onItemClick && e.target !== ref.current && ref.current?.contains(e.target)) {
      onItemClick(e);
    }
  }, children });
};
var GenericMenuButtonItem = ({ children, ...rest }) => {
  return (0, import_jsx_runtime.jsx)("li", { className: "str-video__generic-menu--item", children: (0, import_jsx_runtime.jsx)("button", { ...rest, children }) });
};
var Icon = ({ className, icon }) => (0, import_jsx_runtime.jsx)("span", { className: clsx_default("str-video__icon", icon && `str-video__icon--${icon}`, className) });
function usePictureInPictureState(videoElement) {
  const [isPiP, setIsPiP] = (0, import_react.useState)(document.pictureInPictureElement === videoElement);
  if (!videoElement && isPiP)
    setIsPiP(false);
  (0, import_react.useEffect)(() => {
    if (!videoElement)
      return;
    const handlePiP = () => {
      setIsPiP(document.pictureInPictureElement === videoElement);
    };
    videoElement.addEventListener("enterpictureinpicture", handlePiP);
    videoElement.addEventListener("leavepictureinpicture", handlePiP);
    return () => {
      videoElement.removeEventListener("enterpictureinpicture", handlePiP);
      videoElement.removeEventListener("leavepictureinpicture", handlePiP);
    };
  }, [videoElement]);
  return isPiP;
}
var ParticipantActionsContextMenu = () => {
  const { participant, participantViewElement, videoElement } = useParticipantViewContext();
  const [fullscreenModeOn, setFullscreenModeOn] = (0, import_react.useState)(!!document.fullscreenElement);
  const call = useCall();
  const isPiP = usePictureInPictureState(videoElement ?? void 0);
  const { t } = useI18n();
  const { pin, sessionId, userId } = participant;
  const hasAudioTrack = hasAudio(participant);
  const hasVideoTrack = hasVideo(participant);
  const hasScreenShareTrack = hasScreenShare(participant);
  const hasScreenShareAudioTrack = hasScreenShareAudio(participant);
  const blockUser = () => call?.blockUser(userId);
  const kickUser = () => call?.kickUser({ user_id: userId });
  const muteAudio = () => call?.muteUser(userId, "audio");
  const muteVideo = () => call?.muteUser(userId, "video");
  const muteScreenShare = () => call?.muteUser(userId, "screenshare");
  const muteScreenShareAudio = () => call?.muteUser(userId, "screenshare_audio");
  const grantPermission = (permission) => () => {
    call?.updateUserPermissions({
      user_id: userId,
      grant_permissions: [permission]
    });
  };
  const revokePermission = (permission) => () => {
    call?.updateUserPermissions({
      user_id: userId,
      revoke_permissions: [permission]
    });
  };
  const toggleParticipantPin = () => {
    if (pin) {
      call?.unpin(sessionId);
    } else {
      call?.pin(sessionId);
    }
  };
  const pinForEveryone = () => {
    call?.pinForEveryone({ user_id: userId, session_id: sessionId }).catch((err) => {
      console.error(`Failed to pin participant ${userId}`, err);
    });
  };
  const unpinForEveryone = () => {
    call?.unpinForEveryone({ user_id: userId, session_id: sessionId }).catch((err) => {
      console.error(`Failed to unpin participant ${userId}`, err);
    });
  };
  const toggleFullscreenMode = () => {
    if (!fullscreenModeOn) {
      return participantViewElement?.requestFullscreen().catch(console.error);
    }
    return document.exitFullscreen().catch(console.error);
  };
  (0, import_react.useEffect)(() => {
    const handleFullscreenChange = () => {
      setFullscreenModeOn(!!document.fullscreenElement);
    };
    document.addEventListener("fullscreenchange", handleFullscreenChange);
    return () => {
      document.removeEventListener("fullscreenchange", handleFullscreenChange);
    };
  }, []);
  const togglePictureInPicture = () => {
    if (videoElement && !isPiP) {
      return videoElement.requestPictureInPicture().catch(console.error);
    }
    return document.exitPictureInPicture().catch(console.error);
  };
  const { close } = useMenuContext() || {};
  return (0, import_jsx_runtime.jsxs)(GenericMenu, { onItemClick: close, children: [(0, import_jsx_runtime.jsxs)(GenericMenuButtonItem, { onClick: toggleParticipantPin, disabled: pin && !pin.isLocalPin, children: [(0, import_jsx_runtime.jsx)(Icon, { icon: "pin" }), pin ? t("Unpin") : t("Pin")] }), (0, import_jsx_runtime.jsxs)(Restricted, { requiredGrants: [OwnCapability.PIN_FOR_EVERYONE], children: [(0, import_jsx_runtime.jsxs)(GenericMenuButtonItem, { onClick: pinForEveryone, disabled: pin && !pin.isLocalPin, children: [(0, import_jsx_runtime.jsx)(Icon, { icon: "pin" }), t("Pin for everyone")] }), (0, import_jsx_runtime.jsxs)(GenericMenuButtonItem, { onClick: unpinForEveryone, disabled: !pin || pin.isLocalPin, children: [(0, import_jsx_runtime.jsx)(Icon, { icon: "pin" }), t("Unpin for everyone")] })] }), (0, import_jsx_runtime.jsx)(Restricted, { requiredGrants: [OwnCapability.BLOCK_USERS], children: (0, import_jsx_runtime.jsxs)(GenericMenuButtonItem, { onClick: blockUser, children: [(0, import_jsx_runtime.jsx)(Icon, { icon: "not-allowed" }), t("Block")] }) }), (0, import_jsx_runtime.jsx)(Restricted, { requiredGrants: [OwnCapability.KICK_USER], children: (0, import_jsx_runtime.jsxs)(GenericMenuButtonItem, { onClick: kickUser, children: [(0, import_jsx_runtime.jsx)(Icon, { icon: "kick-user" }), t("Kick")] }) }), (0, import_jsx_runtime.jsxs)(Restricted, { requiredGrants: [OwnCapability.MUTE_USERS], children: [hasVideoTrack && (0, import_jsx_runtime.jsxs)(GenericMenuButtonItem, { onClick: muteVideo, children: [(0, import_jsx_runtime.jsx)(Icon, { icon: "camera-off-outline" }), t("Turn off video")] }), hasScreenShareTrack && (0, import_jsx_runtime.jsxs)(GenericMenuButtonItem, { onClick: muteScreenShare, children: [(0, import_jsx_runtime.jsx)(Icon, { icon: "screen-share-off" }), t("Turn off screen share")] }), hasAudioTrack && (0, import_jsx_runtime.jsxs)(GenericMenuButtonItem, { onClick: muteAudio, children: [(0, import_jsx_runtime.jsx)(Icon, { icon: "no-audio" }), t("Mute audio")] }), hasScreenShareAudioTrack && (0, import_jsx_runtime.jsxs)(GenericMenuButtonItem, { onClick: muteScreenShareAudio, children: [(0, import_jsx_runtime.jsx)(Icon, { icon: "no-audio" }), t("Mute screen share audio")] })] }), participantViewElement && typeof participantViewElement.requestFullscreen !== "undefined" && (0, import_jsx_runtime.jsx)(GenericMenuButtonItem, { onClick: toggleFullscreenMode, children: t("{{ direction }} fullscreen", {
    direction: fullscreenModeOn ? t("Leave") : t("Enter")
  }) }), videoElement && document.pictureInPictureEnabled && (0, import_jsx_runtime.jsx)(GenericMenuButtonItem, { onClick: togglePictureInPicture, children: t("{{ direction }} picture-in-picture", {
    direction: isPiP ? t("Leave") : t("Enter")
  }) }), (0, import_jsx_runtime.jsxs)(Restricted, { requiredGrants: [OwnCapability.UPDATE_CALL_PERMISSIONS], children: [(0, import_jsx_runtime.jsx)(GenericMenuButtonItem, { onClick: grantPermission(OwnCapability.SEND_AUDIO), children: t("Allow audio") }), (0, import_jsx_runtime.jsx)(GenericMenuButtonItem, { onClick: grantPermission(OwnCapability.SEND_VIDEO), children: t("Allow video") }), (0, import_jsx_runtime.jsx)(GenericMenuButtonItem, { onClick: grantPermission(OwnCapability.SCREENSHARE), children: t("Allow screen sharing") }), (0, import_jsx_runtime.jsx)(GenericMenuButtonItem, { onClick: revokePermission(OwnCapability.SEND_AUDIO), children: t("Disable audio") }), (0, import_jsx_runtime.jsx)(GenericMenuButtonItem, { onClick: revokePermission(OwnCapability.SEND_VIDEO), children: t("Disable video") }), (0, import_jsx_runtime.jsx)(GenericMenuButtonItem, { onClick: revokePermission(OwnCapability.SCREENSHARE), children: t("Disable screen sharing") })] })] });
};
var isComponentType = (elementOrComponent) => {
  return elementOrComponent === null ? false : !(0, import_react.isValidElement)(elementOrComponent);
};
var chunk = (array, size2) => {
  const chunkCount = Math.ceil(array.length / size2);
  return Array.from({ length: chunkCount }, (_, index) => array.slice(size2 * index, size2 * index + size2));
};
var applyElementToRef = (ref, element) => {
  if (!ref)
    return;
  if (typeof ref === "function")
    return ref(element);
  ref.current = element;
};
var BaseVideo = (0, import_react.forwardRef)(function BaseVideo2({ stream, ...rest }, ref) {
  const [videoElement, setVideoElement] = (0, import_react.useState)(null);
  (0, import_react.useEffect)(() => {
    if (!videoElement || !stream)
      return;
    if (stream === videoElement.srcObject)
      return;
    videoElement.srcObject = stream;
    if (browsers.isSafari() || browsers.isFirefox()) {
      setTimeout(() => {
        videoElement.srcObject = stream;
        videoElement.play().catch((e) => {
          console.error(`Failed to play stream`, e);
        });
      }, 0);
    }
    return () => {
      videoElement.pause();
      videoElement.srcObject = null;
    };
  }, [stream, videoElement]);
  return (0, import_jsx_runtime.jsx)("video", { autoPlay: true, playsInline: true, ...rest, ref: (element) => {
    applyElementToRef(ref, element);
    setVideoElement(element);
  } });
});
var BaseVideoPlaceholder = (0, import_react.forwardRef)(function DefaultVideoPlaceholder({ participant, style, children }, ref) {
  const [error, setError] = (0, import_react.useState)(false);
  const name2 = participant.name || participant.userId;
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__video-placeholder", style, ref, children: [(!participant.image || error) && (name2 ? (0, import_jsx_runtime.jsx)(InitialsFallback, { name: name2 }) : (0, import_jsx_runtime.jsx)("div", { className: "str-video__video-placeholder__no-video-label", children })), participant.image && !error && (0, import_jsx_runtime.jsx)("img", { onError: () => setError(true), alt: name2, className: "str-video__video-placeholder__avatar", src: participant.image })] });
});
var InitialsFallback = (props) => {
  const { name: name2 } = props;
  const initials = name2.split(" ").slice(0, 2).map((n) => n[0]).join("");
  return (0, import_jsx_runtime.jsx)("div", { className: "str-video__video-placeholder__initials-fallback", children: initials });
};
var DefaultVideoPlaceholder2 = (0, import_react.forwardRef)(function DefaultVideoPlaceholder3(props, ref) {
  const { t } = useI18n();
  return (0, import_jsx_runtime.jsx)(BaseVideoPlaceholder, { ref, ...props, children: t("Video is disabled") });
});
var DefaultPictureInPicturePlaceholder = (0, import_react.forwardRef)(function DefaultPictureInPicturePlaceholder2(props, ref) {
  const { t } = useI18n();
  return (0, import_jsx_runtime.jsx)(BaseVideoPlaceholder, { ref, ...props, children: t("Video is playing in a popup") });
});
var Video$1 = ({ enabled = true, mirror, trackType, participant, className, VideoPlaceholder = DefaultVideoPlaceholder2, PictureInPicturePlaceholder = DefaultPictureInPicturePlaceholder, refs, ...rest }) => {
  const { sessionId, videoStream, screenShareStream, viewportVisibilityState, isLocalParticipant, userId } = participant;
  const call = useCall();
  const [videoElement, setVideoElement] = (0, import_react.useState)(null);
  const [isVideoPaused, setIsVideoPaused] = (0, import_react.useState)(true);
  const [isWideMode, setIsWideMode] = (0, import_react.useState)(true);
  const isPiP = usePictureInPictureState(videoElement ?? void 0);
  const stream = trackType === "videoTrack" ? videoStream : trackType === "screenShareTrack" ? screenShareStream : void 0;
  (0, import_react.useLayoutEffect)(() => {
    if (!call || !videoElement || trackType === "none")
      return;
    const cleanup = call.bindVideoElement(videoElement, sessionId, trackType);
    return () => {
      cleanup?.();
    };
  }, [call, trackType, sessionId, videoElement]);
  (0, import_react.useEffect)(() => {
    if (!stream || !videoElement)
      return;
    const [track] = stream.getVideoTracks();
    if (!track)
      return;
    const handlePlayPause = () => {
      setIsVideoPaused(videoElement.paused);
      const { width = 0, height = 0 } = track.getSettings();
      setIsWideMode(width >= height);
    };
    setIsVideoPaused(videoElement.paused);
    videoElement.addEventListener("play", handlePlayPause);
    videoElement.addEventListener("pause", handlePlayPause);
    track.addEventListener("unmute", handlePlayPause);
    return () => {
      videoElement.removeEventListener("play", handlePlayPause);
      videoElement.removeEventListener("pause", handlePlayPause);
      track.removeEventListener("unmute", handlePlayPause);
      setIsVideoPaused(true);
    };
  }, [stream, videoElement]);
  if (!call)
    return null;
  const isPublishingTrack = trackType === "videoTrack" ? hasVideo(participant) : trackType === "screenShareTrack" ? hasScreenShare(participant) : false;
  const isInvisible = trackType === "none" || viewportVisibilityState?.[trackType] === VisibilityState.INVISIBLE;
  const hasNoVideoOrInvisible = !enabled || !isPublishingTrack || isInvisible || hasPausedTrack(participant, trackType);
  const mirrorVideo = mirror === void 0 ? isLocalParticipant && trackType === "videoTrack" : mirror;
  const isScreenShareTrack = trackType === "screenShareTrack";
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [!hasNoVideoOrInvisible && (0, import_jsx_runtime.jsx)("video", { ...rest, className: clsx_default("str-video__video", className, {
    "str-video__video--not-playing": isVideoPaused,
    "str-video__video--tall": !isWideMode,
    "str-video__video--mirror": mirrorVideo,
    "str-video__video--screen-share": isScreenShareTrack
  }), "data-user-id": userId, "data-session-id": sessionId, ref: (element) => {
    setVideoElement(element);
    refs?.setVideoElement?.(element);
  } }), isPiP && PictureInPicturePlaceholder && (0, import_jsx_runtime.jsx)(PictureInPicturePlaceholder, { style: { position: "absolute" }, participant }), (hasNoVideoOrInvisible || isVideoPaused) && VideoPlaceholder && (0, import_jsx_runtime.jsx)(VideoPlaceholder, { style: { position: "absolute" }, participant, ref: refs?.setVideoPlaceholderElement })] });
};
Video$1.displayName = "Video";
var useTrackElementVisibility = ({ trackedElement, dynascaleManager: propsDynascaleManager, sessionId, trackType }) => {
  const call = useCall();
  const manager = propsDynascaleManager ?? call?.dynascaleManager;
  (0, import_react.useEffect)(() => {
    if (!trackedElement || !manager || !call || trackType === "none")
      return;
    const unobserve = manager.trackElementVisibility(trackedElement, sessionId, trackType);
    return () => {
      unobserve();
    };
  }, [trackedElement, manager, call, sessionId, trackType]);
};
var Avatar = ({ imageSrc, name: name2, style, className, ...rest }) => {
  const [error, setError] = (0, import_react.useState)(false);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(!imageSrc || error) && name2 && (0, import_jsx_runtime.jsx)(AvatarFallback, { className, style, names: [name2] }), imageSrc && !error && (0, import_jsx_runtime.jsx)("img", { onError: () => setError(true), alt: "avatar", className: clsx_default("str-video__avatar", className), src: imageSrc, style, ...rest })] });
};
var AvatarFallback = ({ className, names, style }) => {
  return (0, import_jsx_runtime.jsx)("div", { className: clsx_default("str-video__avatar--initials-fallback", className), style, children: (0, import_jsx_runtime.jsxs)("div", { children: [names[0][0], names[1]?.[0]] }) });
};
var BackgroundFiltersProviderImpl = (0, import_react.lazy)(() => import("./background-filters-CysVAG5J.es-YHHJODCH.js").then((m) => ({
  default: m.BackgroundFiltersProvider
})));
var BackgroundFiltersContext = (0, import_react.createContext)(void 0);
var useBackgroundFilters = () => {
  const context = (0, import_react.useContext)(BackgroundFiltersContext);
  if (!context) {
    throw new Error("useBackgroundFilters must be used within a BackgroundFiltersProvider");
  }
  return context;
};
var BackgroundFiltersProvider = (props) => {
  const { SuspenseFallback = null, ...filterProps } = props;
  return (0, import_jsx_runtime.jsx)(import_react.Suspense, { fallback: SuspenseFallback, children: (0, import_jsx_runtime.jsx)(BackgroundFiltersProviderImpl, { ...filterProps, ContextProvider: BackgroundFiltersContext }) });
};
var IconButton = (0, import_react.forwardRef)(function IconButton2(props, ref) {
  const { icon, enabled, variant, onClick, className, ...rest } = props;
  return (0, import_jsx_runtime.jsx)("button", { className: clsx_default("str-video__call-controls__button", className, {
    [`str-video__call-controls__button--variant-${variant}`]: variant,
    "str-video__call-controls__button--enabled": enabled
  }), onClick: (e) => {
    e.preventDefault();
    onClick?.(e);
  }, ref, ...rest, children: (0, import_jsx_runtime.jsx)(Icon, { icon }) });
});
var CompositeButton = (0, import_react.forwardRef)(function CompositeButton2({ disabled, caption, children, className, active, Menu: Menu2, menuPlacement, menuOffset, title, ToggleMenuButton: ToggleMenuButton3 = DefaultToggleMenuButton, variant, onClick, onMenuToggle, ...restButtonProps }, ref) {
  return (0, import_jsx_runtime.jsxs)("div", { className: clsx_default("str-video__composite-button", className, {
    "str-video__composite-button--caption": caption,
    "str-video__composite-button--menu": Menu2
  }), title, ref, children: [(0, import_jsx_runtime.jsxs)("div", { className: clsx_default("str-video__composite-button__button-group", {
    "str-video__composite-button__button-group--active": active,
    "str-video__composite-button__button-group--active-primary": active && variant === "primary",
    "str-video__composite-button__button-group--active-secondary": active && variant === "secondary",
    "str-video__composite-button__button-group--disabled": disabled
  }), children: [(0, import_jsx_runtime.jsx)("button", { type: "button", className: "str-video__composite-button__button", onClick: (e) => {
    e.preventDefault();
    onClick?.(e);
  }, disabled, ...restButtonProps, children }), Menu2 && (0, import_jsx_runtime.jsx)(MenuToggle, { offset: menuOffset, placement: menuPlacement, ToggleButton: ToggleMenuButton3, onToggle: onMenuToggle, children: isComponentType(Menu2) ? (0, import_jsx_runtime.jsx)(Menu2, {}) : Menu2 })] }), caption && (0, import_jsx_runtime.jsx)("div", { className: "str-video__composite-button__caption", children: caption })] });
});
var DefaultToggleMenuButton = (0, import_react.forwardRef)(function DefaultToggleMenuButton2({ menuShown }, ref) {
  return (0, import_jsx_runtime.jsx)(IconButton, { className: clsx_default("str-video__menu-toggle-button", {
    "str-video__menu-toggle-button--active": menuShown
  }), icon: menuShown ? "caret-down" : "caret-up", ref });
});
var TextButton = ({ children, ...rest }) => {
  return (0, import_jsx_runtime.jsx)("button", { ...rest, className: "str-video__text-button", children });
};
var AcceptCallButton = ({ disabled, onAccept, onClick }) => {
  const call = useCall();
  const handleClick = (0, import_react.useCallback)(async (e) => {
    if (onClick) {
      onClick(e);
    } else if (call) {
      await call.join();
      onAccept?.();
    }
  }, [onClick, onAccept, call]);
  return (0, import_jsx_runtime.jsx)(IconButton, { disabled, icon: "call-accept", variant: "success", "data-testid": "accept-call-button", onClick: handleClick });
};
var Notification = (props) => {
  const { isVisible, message, children, visibilityTimeout, resetIsVisible, placement = "top", className, iconClassName = "str-video__notification__icon", close } = props;
  const { refs, x, y, strategy } = useFloatingUIPreset({
    placement,
    strategy: "absolute"
  });
  (0, import_react.useEffect)(() => {
    if (!isVisible || !visibilityTimeout || !resetIsVisible)
      return;
    const timeout = setTimeout(() => {
      resetIsVisible();
    }, visibilityTimeout);
    return () => clearTimeout(timeout);
  }, [isVisible, resetIsVisible, visibilityTimeout]);
  return (0, import_jsx_runtime.jsxs)("div", { ref: refs.setReference, children: [isVisible && (0, import_jsx_runtime.jsxs)("div", { className: clsx_default("str-video__notification", className), ref: refs.setFloating, style: {
    position: strategy,
    top: y ?? 0,
    left: x ?? 0,
    overflowY: "auto"
  }, children: [iconClassName && (0, import_jsx_runtime.jsx)("i", { className: iconClassName }), (0, import_jsx_runtime.jsx)("span", { className: "str-video__notification__message", children: message }), close ? (0, import_jsx_runtime.jsx)("i", { className: "str-video__icon str-video__icon--close str-video__notification__close", onClick: close }) : null] }), children] });
};
var PermissionNotification = (props) => {
  const { permission, isAwaitingApproval, messageApproved, messageAwaitingApproval, messageRevoked, visibilityTimeout = 3500, children } = props;
  const { useHasPermissions } = useCallStateHooks();
  const hasPermission = useHasPermissions(permission);
  const prevHasPermission = (0, import_react.useRef)(hasPermission);
  const [showNotification, setShowNotification] = (0, import_react.useState)();
  (0, import_react.useEffect)(() => {
    if (prevHasPermission.current === hasPermission)
      return;
    if (hasPermission) {
      setShowNotification("granted");
      prevHasPermission.current = true;
    } else {
      setShowNotification("revoked");
      prevHasPermission.current = false;
    }
  }, [hasPermission]);
  const resetIsVisible = (0, import_react.useCallback)(() => setShowNotification(void 0), []);
  if (isAwaitingApproval) {
    return (0, import_jsx_runtime.jsx)(Notification, { isVisible: isAwaitingApproval && !hasPermission, message: messageAwaitingApproval, children });
  }
  return (0, import_jsx_runtime.jsx)(Notification, { isVisible: !!showNotification, visibilityTimeout, resetIsVisible, message: showNotification === "granted" ? messageApproved : messageRevoked, children });
};
var SpeakingWhileMutedNotification = ({ children, text, placement }) => {
  const { useMicrophoneState } = useCallStateHooks();
  const { isSpeakingWhileMuted } = useMicrophoneState();
  const { t } = useI18n();
  const message = text ?? t("You are muted. Unmute to speak.");
  return (0, import_jsx_runtime.jsx)(Notification, { message, isVisible: isSpeakingWhileMuted, placement: placement || "top-start", children });
};
var RecordingInProgressNotification = ({ children, text }) => {
  const { t } = useI18n();
  const { isCallRecordingInProgress } = useToggleCallRecording();
  const [isVisible, setVisible] = (0, import_react.useState)(false);
  const message = text ?? t("Recording in progress...");
  (0, import_react.useEffect)(() => {
    if (isCallRecordingInProgress) {
      setVisible(true);
    } else {
      setVisible(false);
    }
  }, [isCallRecordingInProgress]);
  return (0, import_jsx_runtime.jsx)(Notification, { message, iconClassName: "str-video__icon str-video__icon--recording-on", isVisible, placement: "top-start", close: () => setVisible(false), children });
};
var LoadingIndicator = ({ className, type = "spinner", text, tooltip }) => {
  return (0, import_jsx_runtime.jsxs)("div", { className: clsx_default("str-video__loading-indicator", className), title: tooltip, children: [(0, import_jsx_runtime.jsx)("div", { className: clsx_default("str-video__loading-indicator__icon", type) }), text && (0, import_jsx_runtime.jsx)("p", { className: "str-video__loading-indicator-text", children: text })] });
};
var Tooltip = ({ children, referenceElement, tooltipClassName, tooltipPlacement = "top", visible = false }) => {
  const arrowRef = (0, import_react.useRef)(null);
  const { refs, x, y, strategy, context } = useFloatingUIPreset({
    placement: tooltipPlacement,
    strategy: "absolute",
    middleware: [arrow({ element: arrowRef })]
  });
  (0, import_react.useEffect)(() => {
    refs.setReference(referenceElement);
  }, [referenceElement, refs]);
  if (!visible)
    return null;
  return (0, import_jsx_runtime.jsxs)("div", { className: clsx_default("str-video__tooltip", tooltipClassName), ref: refs.setFloating, style: {
    position: strategy,
    top: y ?? 0,
    left: x ?? 0
  }, children: [(0, import_jsx_runtime.jsx)(FloatingArrow, { ref: arrowRef, context, fill: "var(--str-video__tooltip--background-color)" }), children] });
};
var useEnterLeaveHandlers = ({ onMouseEnter, onMouseLeave } = {}) => {
  const [tooltipVisible, setTooltipVisible] = (0, import_react.useState)(false);
  const handleMouseEnter = (0, import_react.useCallback)((e) => {
    setTooltipVisible(true);
    onMouseEnter?.(e);
  }, [onMouseEnter]);
  const handleMouseLeave = (0, import_react.useCallback)((e) => {
    setTooltipVisible(false);
    onMouseLeave?.(e);
  }, [onMouseLeave]);
  return { handleMouseEnter, handleMouseLeave, tooltipVisible };
};
var WithTooltip = ({ title, tooltipClassName, tooltipPlacement, tooltipDisabled, ...props }) => {
  const { handleMouseEnter, handleMouseLeave, tooltipVisible } = useEnterLeaveHandlers();
  const [tooltipAnchor, setTooltipAnchor] = (0, import_react.useState)(null);
  const tooltipActuallyVisible = !tooltipDisabled && Boolean(title) && tooltipVisible;
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(Tooltip, { referenceElement: tooltipAnchor, visible: tooltipActuallyVisible, tooltipClassName, tooltipPlacement, children: title || "" }), (0, import_jsx_runtime.jsx)("div", { ref: setTooltipAnchor, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, ...props })] });
};
var RecordEndConfirmation = () => {
  const { t } = useI18n();
  const { toggleCallRecording, isAwaitingResponse } = useToggleCallRecording();
  const { close } = useMenuContext();
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__end-recording__confirmation", children: [(0, import_jsx_runtime.jsxs)("div", { className: "str-video__end-recording__header", children: [(0, import_jsx_runtime.jsx)(Icon, { icon: "recording-on" }), (0, import_jsx_runtime.jsx)("h2", { className: "str-video__end-recording__heading", children: t("End recording") })] }), (0, import_jsx_runtime.jsx)("p", { className: "str-video__end-recording__description", children: t("Are you sure you want end the recording?") }), (0, import_jsx_runtime.jsxs)("div", { className: "str-video__end-recording__actions", children: [(0, import_jsx_runtime.jsx)(CompositeButton, { variant: "secondary", onClick: close, children: t("Cancel") }), (0, import_jsx_runtime.jsx)(CompositeButton, { variant: "primary", onClick: toggleCallRecording, children: isAwaitingResponse ? (0, import_jsx_runtime.jsx)(LoadingIndicator, {}) : t("End recording") })] })] });
};
var ToggleEndRecordingMenuButton = (0, import_react.forwardRef)(function ToggleEndRecordingMenuButton2(props, ref) {
  return (0, import_jsx_runtime.jsx)(CompositeButton, { ref, active: true, variant: "secondary", "data-testid": "recording-stop-button", children: (0, import_jsx_runtime.jsx)(Icon, { icon: "recording-off" }) });
});
var RecordCallConfirmationButton = ({ caption }) => {
  const { t } = useI18n();
  const { toggleCallRecording, isAwaitingResponse, isCallRecordingInProgress } = useToggleCallRecording();
  if (isCallRecordingInProgress) {
    return (0, import_jsx_runtime.jsx)(Restricted, { requiredGrants: [
      OwnCapability.START_RECORD_CALL,
      OwnCapability.STOP_RECORD_CALL
    ], children: (0, import_jsx_runtime.jsx)(MenuToggle, { ToggleButton: ToggleEndRecordingMenuButton, visualType: MenuVisualType.PORTAL, children: (0, import_jsx_runtime.jsx)(RecordEndConfirmation, {}) }) });
  }
  const title = isAwaitingResponse ? t("Waiting for recording to start...") : caption ?? t("Record call");
  return (0, import_jsx_runtime.jsx)(Restricted, { requiredGrants: [
    OwnCapability.START_RECORD_CALL,
    OwnCapability.STOP_RECORD_CALL
  ], children: (0, import_jsx_runtime.jsx)(WithTooltip, { title, children: (0, import_jsx_runtime.jsx)(CompositeButton, { active: isCallRecordingInProgress, caption, variant: "secondary", "data-testid": "recording-start-button", onClick: isAwaitingResponse ? void 0 : toggleCallRecording, children: isAwaitingResponse ? (0, import_jsx_runtime.jsx)(LoadingIndicator, {}) : (0, import_jsx_runtime.jsx)(Icon, { icon: "recording-off" }) }) }) });
};
var RecordCallButton = ({ caption }) => {
  const { t } = useI18n();
  const { toggleCallRecording, isAwaitingResponse, isCallRecordingInProgress } = useToggleCallRecording();
  let title = caption ?? t("Record call");
  if (isAwaitingResponse) {
    title = isCallRecordingInProgress ? t("Waiting for recording to stop...") : t("Waiting for recording to start...");
  }
  return (0, import_jsx_runtime.jsx)(Restricted, { requiredGrants: [
    OwnCapability.START_RECORD_CALL,
    OwnCapability.STOP_RECORD_CALL
  ], children: (0, import_jsx_runtime.jsx)(CompositeButton, { active: isCallRecordingInProgress, caption, variant: "secondary", "data-testid": isCallRecordingInProgress ? "recording-stop-button" : "recording-start-button", title, onClick: isAwaitingResponse ? void 0 : toggleCallRecording, children: isAwaitingResponse ? (0, import_jsx_runtime.jsx)(LoadingIndicator, {}) : (0, import_jsx_runtime.jsx)(Icon, { icon: isCallRecordingInProgress ? "recording-on" : "recording-off" }) }) });
};
var defaultEmojiReactionMap = {
  ":like:": "",
  ":raise-hand:": "",
  ":fireworks:": "",
  ":dislike:": "",
  ":heart:": "",
  ":smile:": ""
};
var Reaction = ({ participant: { reaction, sessionId }, hideAfterTimeoutInMs = 5500, emojiReactionMap = defaultEmojiReactionMap }) => {
  const call = useCall();
  (0, import_react.useEffect)(() => {
    if (!call || !reaction)
      return;
    const timeoutId = setTimeout(() => {
      call.resetReaction(sessionId);
    }, hideAfterTimeoutInMs);
    return () => {
      clearTimeout(timeoutId);
    };
  }, [call, hideAfterTimeoutInMs, reaction, sessionId]);
  if (!reaction)
    return null;
  const { emoji_code: emojiCode } = reaction;
  return (0, import_jsx_runtime.jsx)("div", { className: "str-video__reaction", children: (0, import_jsx_runtime.jsx)("span", { className: "str-video__reaction__emoji", children: emojiCode && emojiReactionMap[emojiCode] }) });
};
var defaultReactions = [
  {
    type: "reaction",
    emoji_code: ":like:"
  },
  {
    // TODO OL: use `prompt` type?
    type: "raised-hand",
    emoji_code: ":raise-hand:"
  },
  {
    type: "reaction",
    emoji_code: ":fireworks:"
  },
  {
    type: "reaction",
    emoji_code: ":dislike:"
  },
  {
    type: "reaction",
    emoji_code: ":heart:"
  },
  {
    type: "reaction",
    emoji_code: ":smile:"
  }
];
var ReactionsButton = ({ reactions = defaultReactions }) => {
  return (0, import_jsx_runtime.jsx)(Restricted, { requiredGrants: [OwnCapability.CREATE_REACTION], children: (0, import_jsx_runtime.jsx)(MenuToggle, { placement: "top", ToggleButton: ToggleReactionsMenuButton, visualType: MenuVisualType.MENU, children: (0, import_jsx_runtime.jsx)(DefaultReactionsMenu, { reactions }) }) });
};
var ToggleReactionsMenuButton = (0, import_react.forwardRef)(function ToggleReactionsMenuButton2({ menuShown }, ref) {
  const { t } = useI18n();
  return (0, import_jsx_runtime.jsx)(WithTooltip, { title: t("Reactions"), tooltipDisabled: menuShown, children: (0, import_jsx_runtime.jsx)(CompositeButton, { ref, active: menuShown, variant: "primary", children: (0, import_jsx_runtime.jsx)(Icon, { icon: "reactions" }) }) });
});
var DefaultReactionsMenu = ({ reactions, layout = "horizontal" }) => {
  const call = useCall();
  const { close } = useMenuContext();
  return (0, import_jsx_runtime.jsx)("div", { className: clsx_default("str-video__reactions-menu", {
    "str-video__reactions-menu--horizontal": layout === "horizontal",
    "str-video__reactions-menu--vertical": layout === "vertical"
  }), children: reactions.map((reaction) => (0, import_jsx_runtime.jsx)("button", { type: "button", className: "str-video__reactions-menu__button", onClick: () => {
    call?.sendReaction(reaction);
    close?.();
  }, children: reaction.emoji_code && defaultEmojiReactionMap[reaction.emoji_code] }, reaction.emoji_code)) });
};
var createCallControlHandler = (props, handler) => {
  return async () => {
    try {
      await handler();
    } catch (error) {
      if (props.onError) {
        props.onError(error);
        return;
      }
      if (!isNotAllowedError(error)) {
        console.error("Call control handler failed", error);
      }
    }
  };
};
function isNotAllowedError(error) {
  return error instanceof DOMException && error.name === "NotAllowedError";
}
var ScreenShareButton = (props) => {
  const { t } = useI18n();
  const { caption, optimisticUpdates } = props;
  const { useHasOngoingScreenShare, useScreenShareState, useCallSettings } = useCallStateHooks();
  const isSomeoneScreenSharing = useHasOngoingScreenShare();
  const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(OwnCapability.SCREENSHARE);
  const callSettings = useCallSettings();
  const isScreenSharingAllowed = callSettings?.screensharing.enabled;
  const { screenShare, optionsAwareIsMute, isTogglePending } = useScreenShareState({
    optimisticUpdates
  });
  const amIScreenSharing = !optionsAwareIsMute;
  const disableScreenShareButton = !amIScreenSharing && (isSomeoneScreenSharing || isScreenSharingAllowed === false) || !optimisticUpdates && isTogglePending;
  const handleClick = createCallControlHandler(props, async () => {
    if (!hasPermission) {
      await requestPermission();
    } else {
      await screenShare.toggle();
    }
  });
  return (0, import_jsx_runtime.jsx)(Restricted, { requiredGrants: [OwnCapability.SCREENSHARE], children: (0, import_jsx_runtime.jsx)(PermissionNotification, { permission: OwnCapability.SCREENSHARE, isAwaitingApproval: isAwaitingPermission, messageApproved: t("You can now share your screen."), messageAwaitingApproval: t("Awaiting for an approval to share screen."), messageRevoked: t("You can no longer share your screen."), children: (0, import_jsx_runtime.jsx)(WithTooltip, { title: caption ?? t("Share screen"), children: (0, import_jsx_runtime.jsx)(CompositeButton, { active: isSomeoneScreenSharing || amIScreenSharing, caption, variant: "primary", "data-testid": isSomeoneScreenSharing ? "screen-share-stop-button" : "screen-share-start-button", disabled: disableScreenShareButton, onClick: handleClick, children: (0, import_jsx_runtime.jsx)(Icon, { icon: isSomeoneScreenSharing ? "screen-share-on" : "screen-share-off" }) }) }) }) });
};
var AudioVolumeIndicator = () => {
  const { useMicrophoneState } = useCallStateHooks();
  const { isEnabled, mediaStream } = useMicrophoneState();
  const [audioLevel, setAudioLevel] = (0, import_react.useState)(0);
  (0, import_react.useEffect)(() => {
    if (!isEnabled || !mediaStream)
      return;
    const disposeSoundDetector = createSoundDetector(mediaStream, ({ audioLevel: al }) => setAudioLevel(al), { detectionFrequencyInMs: 80, destroyStreamOnStop: false });
    return () => {
      disposeSoundDetector().catch(console.error);
    };
  }, [isEnabled, mediaStream]);
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__audio-volume-indicator", children: [(0, import_jsx_runtime.jsx)(Icon, { icon: isEnabled ? "mic" : "mic-off" }), (0, import_jsx_runtime.jsx)("div", { className: "str-video__audio-volume-indicator__bar", children: (0, import_jsx_runtime.jsx)("div", { className: "str-video__audio-volume-indicator__bar-value", style: { transform: `scaleX(${audioLevel / 100})` } }) })] });
};
var SelectContext = (0, import_react.createContext)({});
var Select = (props) => {
  const { children, icon, defaultSelectedLabel, defaultSelectedIndex, handleSelect: handleSelectProp } = props;
  const [isOpen, setIsOpen] = (0, import_react.useState)(false);
  const [activeIndex, setActiveIndex] = (0, import_react.useState)(null);
  const [selectedIndex, setSelectedIndex] = (0, import_react.useState)(defaultSelectedIndex);
  const [selectedLabel, setSelectedLabel] = (0, import_react.useState)(defaultSelectedLabel);
  const { refs, context } = useFloating({
    placement: "bottom-start",
    open: isOpen,
    onOpenChange: setIsOpen,
    whileElementsMounted: autoUpdate,
    middleware: [flip()]
  });
  const elementsRef = (0, import_react.useRef)([]);
  const labelsRef = (0, import_react.useRef)([]);
  const handleSelect = (0, import_react.useCallback)((index) => {
    setSelectedIndex(index);
    handleSelectProp(index || 0);
    setIsOpen(false);
    if (index !== null) {
      setSelectedLabel(labelsRef.current[index]);
    }
  }, [handleSelectProp]);
  const handleTypeaheadMatch = (index) => {
    if (isOpen) {
      setActiveIndex(index);
    } else {
      handleSelect(index);
    }
  };
  const listNav = useListNavigation(context, {
    listRef: elementsRef,
    activeIndex,
    selectedIndex,
    onNavigate: setActiveIndex
  });
  const typeahead = useTypeahead(context, {
    listRef: labelsRef,
    activeIndex,
    selectedIndex,
    onMatch: handleTypeaheadMatch
  });
  const click = useClick(context);
  const dismiss = useDismiss(context);
  const role2 = useRole(context, { role: "listbox" });
  const { getReferenceProps, getFloatingProps, getItemProps } = useInteractions([listNav, typeahead, click, dismiss, role2]);
  const selectContext = (0, import_react.useMemo)(() => ({
    activeIndex,
    selectedIndex,
    getItemProps,
    handleSelect
  }), [activeIndex, selectedIndex, getItemProps, handleSelect]);
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__dropdown", children: [(0, import_jsx_runtime.jsxs)("div", { className: "str-video__dropdown-selected", ref: refs.setReference, tabIndex: 0, ...getReferenceProps(), children: [(0, import_jsx_runtime.jsxs)("label", { className: "str-video__dropdown-selected__label", children: [icon && (0, import_jsx_runtime.jsx)(Icon, { className: "str-video__dropdown-selected__icon", icon }), selectedLabel] }), (0, import_jsx_runtime.jsx)(Icon, { className: "str-video__dropdown-selected__chevron", icon: isOpen ? "chevron-up" : "chevron-down" })] }), (0, import_jsx_runtime.jsx)(SelectContext.Provider, { value: selectContext, children: isOpen && (0, import_jsx_runtime.jsx)(FloatingFocusManager, { context, modal: false, children: (0, import_jsx_runtime.jsx)("div", { className: "str-video__dropdown-list", ref: refs.setFloating, ...getFloatingProps(), children: (0, import_jsx_runtime.jsx)(FloatingList, { elementsRef, labelsRef, children }) }) }) })] });
};
var DropDownSelectOption = (props) => {
  const { selected, label, icon } = props;
  const { getItemProps, handleSelect } = (0, import_react.useContext)(SelectContext);
  const { ref, index } = useListItem();
  return (0, import_jsx_runtime.jsxs)("div", { className: clsx_default("str-video__dropdown-option", {
    "str-video__dropdown-option--selected": selected
  }), ref, ...getItemProps({
    onClick: () => handleSelect(index)
  }), children: [icon && (0, import_jsx_runtime.jsx)(Icon, { className: "str-video__dropdown-icon", icon }), (0, import_jsx_runtime.jsx)("span", { className: "str-video__dropdown-label", children: label })] });
};
var DropDownSelect = (props) => {
  const { children, icon, handleSelect, defaultSelectedLabel, defaultSelectedIndex } = props;
  return (0, import_jsx_runtime.jsx)(Select, { icon, handleSelect, defaultSelectedIndex, defaultSelectedLabel, children });
};
var DeviceSelectorOption = ({ disabled, id, label, onChange, name: name2, selected, defaultChecked, value }) => {
  return (0, import_jsx_runtime.jsxs)("label", { className: clsx_default("str-video__device-settings__option", {
    "str-video__device-settings__option--selected": selected,
    "str-video__device-settings__option--disabled": disabled
  }), htmlFor: id, children: [(0, import_jsx_runtime.jsx)("input", { type: "radio", name: name2, onChange, value, id, checked: selected, defaultChecked, disabled }), label] });
};
var DeviceSelectorList = (props) => {
  const { devices = [], selectedDeviceId, title, type, onChange, children } = props;
  const { close } = useMenuContext();
  const { deviceList } = useDeviceList(devices, selectedDeviceId);
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__device-settings__device-kind", children: [title && (0, import_jsx_runtime.jsx)("div", { className: "str-video__device-settings__device-selector-title", children: title }), deviceList.map((device) => {
    return (0, import_jsx_runtime.jsx)(DeviceSelectorOption, { id: `${type}--${device.deviceId}`, value: device.deviceId, label: device.label, onChange: (e) => {
      const deviceId = e.target.value;
      if (deviceId !== "default") {
        onChange?.(deviceId);
      }
      close?.();
    }, name: type, selected: device.isSelected }, device.deviceId);
  }), children] });
};
var DeviceSelectorDropdown = (props) => {
  const { devices = [], selectedDeviceId, title, onChange, icon } = props;
  const { deviceList, selectedDeviceInfo, selectedIndex } = useDeviceList(devices, selectedDeviceId);
  const handleSelect = (0, import_react.useCallback)((index) => {
    const deviceId = deviceList[index].deviceId;
    if (deviceId !== "default") {
      onChange?.(deviceId);
    }
  }, [deviceList, onChange]);
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__device-settings__device-kind", children: [(0, import_jsx_runtime.jsx)("div", { className: "str-video__device-settings__device-selector-title", children: title }), (0, import_jsx_runtime.jsx)(DropDownSelect, { icon, defaultSelectedIndex: selectedIndex, defaultSelectedLabel: selectedDeviceInfo.label, handleSelect, children: deviceList.map((device) => (0, import_jsx_runtime.jsx)(DropDownSelectOption, { icon, label: device.label, selected: device.isSelected }, device.deviceId)) })] });
};
var DeviceSelector = (props) => {
  const { visualType = "list", icon, ...rest } = props;
  if (visualType === "list") {
    return (0, import_jsx_runtime.jsx)(DeviceSelectorList, { ...rest });
  }
  return (0, import_jsx_runtime.jsx)(DeviceSelectorDropdown, { ...rest, icon });
};
var SpeakerTest = (props) => {
  const { useSpeakerState } = useCallStateHooks();
  const { selectedDevice } = useSpeakerState();
  const audioElementRef = (0, import_react.useRef)(null);
  const [isPlaying, setIsPlaying] = (0, import_react.useState)(false);
  const { t } = useI18n();
  const { audioUrl = `https://unpkg.com/${"@stream-io/video-react-sdk"}@${"1.31.6"}/assets/piano.mp3` } = props;
  (0, import_react.useEffect)(() => {
    const audio = audioElementRef.current;
    if (!audio || !selectedDevice)
      return;
    if ("setSinkId" in audio) {
      audio.setSinkId(selectedDevice).catch((err) => {
        console.error("Failed to set audio output device:", err);
      });
    }
  }, [selectedDevice]);
  const handleStartTest = (0, import_react.useCallback)(async () => {
    const audio = audioElementRef.current;
    if (!audio)
      return;
    audio.src = audioUrl;
    try {
      if (isPlaying) {
        audio.pause();
        audio.currentTime = 0;
        setIsPlaying(false);
      } else {
        await audio.play();
        setIsPlaying(true);
      }
    } catch (err) {
      console.error("Failed to play test audio:", err);
      setIsPlaying(false);
    }
  }, [isPlaying, audioUrl]);
  const handleAudioEnded = (0, import_react.useCallback)(() => setIsPlaying(false), []);
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__speaker-test", children: [(0, import_jsx_runtime.jsx)("audio", { ref: audioElementRef, onEnded: handleAudioEnded, onPause: handleAudioEnded }), (0, import_jsx_runtime.jsx)(CompositeButton, { className: "str-video__speaker-test__button", onClick: handleStartTest, type: "button", children: (0, import_jsx_runtime.jsxs)("div", { className: "str-video__speaker-test__button-content", children: [(0, import_jsx_runtime.jsx)(Icon, { icon: "speaker" }), isPlaying ? t("Stop test") : t("Test speaker")] }) })] });
};
var DeviceSelectorAudioInput = ({ title, visualType, volumeIndicatorVisible = true }) => {
  const { useMicrophoneState } = useCallStateHooks();
  const { microphone, selectedDevice, devices } = useMicrophoneState();
  return (0, import_jsx_runtime.jsx)(DeviceSelector, { devices: devices || [], selectedDeviceId: selectedDevice, type: "audioinput", onChange: async (deviceId) => {
    await microphone.select(deviceId);
  }, title, visualType, icon: "mic", children: volumeIndicatorVisible && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("hr", { className: "str-video__device-settings__separator" }), (0, import_jsx_runtime.jsx)(AudioVolumeIndicator, {})] }) });
};
var DeviceSelectorAudioOutput = ({ title, visualType, speakerTestVisible = true, speakerTestAudioUrl }) => {
  const { useSpeakerState } = useCallStateHooks();
  const { speaker, selectedDevice, devices, isDeviceSelectionSupported } = useSpeakerState();
  if (!isDeviceSelectionSupported)
    return null;
  return (0, import_jsx_runtime.jsx)(DeviceSelector, { devices, type: "audiooutput", selectedDeviceId: selectedDevice, onChange: (deviceId) => {
    speaker.select(deviceId);
  }, title, visualType, icon: "speaker", children: speakerTestVisible && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("hr", { className: "str-video__device-settings__separator" }), (0, import_jsx_runtime.jsx)(SpeakerTest, { audioUrl: speakerTestAudioUrl })] }) });
};
var DeviceSelectorVideo = ({ title, visualType }) => {
  const { useCameraState } = useCallStateHooks();
  const { camera, devices, selectedDevice } = useCameraState();
  return (0, import_jsx_runtime.jsx)(DeviceSelector, { devices: devices || [], type: "videoinput", selectedDeviceId: selectedDevice, onChange: async (deviceId) => {
    await camera.select(deviceId);
  }, title, visualType, icon: "camera" });
};
var DeviceSettings = ({ visualType = MenuVisualType.MENU }) => {
  return (0, import_jsx_runtime.jsx)(MenuToggle, { placement: "bottom-end", ToggleButton: ToggleDeviceSettingsMenuButton, visualType, children: (0, import_jsx_runtime.jsx)(Menu, {}) });
};
var Menu = () => {
  const { t } = useI18n();
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__device-settings", children: [(0, import_jsx_runtime.jsx)(DeviceSelectorVideo, { title: t("Select a Camera") }), (0, import_jsx_runtime.jsx)(DeviceSelectorAudioInput, { title: t("Select a Mic") }), (0, import_jsx_runtime.jsx)(DeviceSelectorAudioOutput, { title: t("Select Speakers") })] });
};
var ToggleDeviceSettingsMenuButton = (0, import_react.forwardRef)(function ToggleDeviceSettingsMenuButton2({ menuShown }, ref) {
  const { t } = useI18n();
  return (0, import_jsx_runtime.jsx)(IconButton, { className: clsx_default("str-video__device-settings__button", {
    "str-video__device-settings__button--active": menuShown
  }), title: t("Toggle device menu"), icon: "device-settings", ref });
});
var ToggleAudioPreviewButton = (props) => {
  const { caption, Menu: Menu2 = DeviceSelectorAudioInput, menuPlacement = "top", onMenuToggle, optimisticUpdates, ...restCompositeButtonProps } = props;
  const { t } = useI18n();
  const { useMicrophoneState } = useCallStateHooks();
  const { microphone, hasBrowserPermission, isPromptingPermission, optionsAwareIsMute, isTogglePending } = useMicrophoneState({ optimisticUpdates });
  const [tooltipDisabled, setTooltipDisabled] = (0, import_react.useState)(false);
  const handleClick = createCallControlHandler(props, () => microphone.toggle());
  return (0, import_jsx_runtime.jsx)(WithTooltip, { title: !hasBrowserPermission ? t("Check your browser audio permissions") : caption ?? t("Mic"), tooltipDisabled, children: (0, import_jsx_runtime.jsxs)(CompositeButton, { active: optionsAwareIsMute, caption, className: clsx_default(!hasBrowserPermission && "str-video__device-unavailable"), variant: "secondary", disabled: !hasBrowserPermission || !optimisticUpdates && isTogglePending, "data-testid": optionsAwareIsMute ? "preview-audio-unmute-button" : "preview-audio-mute-button", onClick: handleClick, Menu: Menu2, menuPlacement, ...restCompositeButtonProps, onMenuToggle: (shown) => {
    setTooltipDisabled(shown);
    onMenuToggle?.(shown);
  }, children: [(0, import_jsx_runtime.jsx)(Icon, { icon: !optionsAwareIsMute ? "mic" : "mic-off" }), !hasBrowserPermission && (0, import_jsx_runtime.jsx)("span", { className: "str-video__no-media-permission", title: t("Check your browser audio permissions"), children: "!" }), isPromptingPermission && (0, import_jsx_runtime.jsx)("span", { className: "str-video__pending-permission", title: t("Waiting for permission"), children: "?" })] }) });
};
var ToggleAudioPublishingButton = (props) => {
  const { t } = useI18n();
  const { caption, Menu: Menu2 = (0, import_jsx_runtime.jsx)(DeviceSelectorAudioInput, { visualType: "list" }), menuPlacement = "top", onMenuToggle, optimisticUpdates, ...restCompositeButtonProps } = props;
  const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(OwnCapability.SEND_AUDIO);
  const { useMicrophoneState } = useCallStateHooks();
  const { microphone, hasBrowserPermission, isPromptingPermission, isTogglePending, optionsAwareIsMute } = useMicrophoneState({ optimisticUpdates });
  const [tooltipDisabled, setTooltipDisabled] = (0, import_react.useState)(false);
  const handleClick = createCallControlHandler(props, async () => {
    if (!hasPermission) {
      await requestPermission();
    } else {
      await microphone.toggle();
    }
  });
  return (0, import_jsx_runtime.jsx)(Restricted, { requiredGrants: [OwnCapability.SEND_AUDIO], children: (0, import_jsx_runtime.jsx)(PermissionNotification, { permission: OwnCapability.SEND_AUDIO, isAwaitingApproval: isAwaitingPermission, messageApproved: t("You can now speak."), messageAwaitingApproval: t("Awaiting for an approval to speak."), messageRevoked: t("You can no longer speak."), children: (0, import_jsx_runtime.jsx)(WithTooltip, { title: !hasPermission ? t("You have no permission to share your audio") : !hasBrowserPermission ? t("Check your browser mic permissions") : caption ?? t("Mic"), tooltipDisabled, children: (0, import_jsx_runtime.jsxs)(CompositeButton, { active: optionsAwareIsMute, caption, variant: "secondary", disabled: !hasBrowserPermission || !hasPermission || // disable button while the toggle action is pending when not using optimistic updates
  !optimisticUpdates && isTogglePending, "data-testid": optionsAwareIsMute ? "audio-unmute-button" : "audio-mute-button", onClick: handleClick, Menu: Menu2, menuPlacement, menuOffset: 16, ...restCompositeButtonProps, onMenuToggle: (shown) => {
    setTooltipDisabled(shown);
    onMenuToggle?.(shown);
  }, children: [(0, import_jsx_runtime.jsx)(Icon, { icon: optionsAwareIsMute ? "mic-off" : "mic" }), (!hasBrowserPermission || !hasPermission) && (0, import_jsx_runtime.jsx)("span", { className: "str-video__no-media-permission", children: "!" }), isPromptingPermission && (0, import_jsx_runtime.jsx)("span", { className: "str-video__pending-permission", title: t("Waiting for permission"), children: "?" })] }) }) }) });
};
var ToggleVideoPreviewButton = (props) => {
  const { caption, Menu: Menu2 = DeviceSelectorVideo, menuPlacement = "top", onMenuToggle, optimisticUpdates, ...restCompositeButtonProps } = props;
  const { t } = useI18n();
  const { useCameraState } = useCallStateHooks();
  const { camera, hasBrowserPermission, isPromptingPermission, isTogglePending, optionsAwareIsMute } = useCameraState({ optimisticUpdates });
  const [tooltipDisabled, setTooltipDisabled] = (0, import_react.useState)(false);
  const handleClick = createCallControlHandler(props, () => camera.toggle());
  return (0, import_jsx_runtime.jsx)(WithTooltip, { title: !hasBrowserPermission ? t("Check your browser video permissions") : caption ?? t("Video"), tooltipDisabled, children: (0, import_jsx_runtime.jsxs)(CompositeButton, { active: optionsAwareIsMute, caption, className: clsx_default(!hasBrowserPermission && "str-video__device-unavailable"), variant: "secondary", "data-testid": optionsAwareIsMute ? "preview-video-unmute-button" : "preview-video-mute-button", onClick: handleClick, disabled: !hasBrowserPermission || !optimisticUpdates && isTogglePending, Menu: Menu2, menuPlacement, ...restCompositeButtonProps, onMenuToggle: (shown) => {
    setTooltipDisabled(shown);
    onMenuToggle?.(shown);
  }, children: [(0, import_jsx_runtime.jsx)(Icon, { icon: !optionsAwareIsMute ? "camera" : "camera-off" }), !hasBrowserPermission && (0, import_jsx_runtime.jsx)("span", { className: "str-video__no-media-permission", title: t("Check your browser video permissions"), children: "!" }), isPromptingPermission && (0, import_jsx_runtime.jsx)("span", { className: "str-video__pending-permission", title: t("Waiting for permission"), children: "?" })] }) });
};
var ToggleVideoPublishingButton = (props) => {
  const { t } = useI18n();
  const { caption, Menu: Menu2 = (0, import_jsx_runtime.jsx)(DeviceSelectorVideo, { visualType: "list" }), menuPlacement = "top", onMenuToggle, optimisticUpdates, ...restCompositeButtonProps } = props;
  const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(OwnCapability.SEND_VIDEO);
  const { useCameraState, useCallSettings } = useCallStateHooks();
  const { camera, optionsAwareIsMute, hasBrowserPermission, isPromptingPermission, isTogglePending } = useCameraState({ optimisticUpdates });
  const callSettings = useCallSettings();
  const isPublishingVideoAllowed = callSettings?.video.enabled;
  const [tooltipDisabled, setTooltipDisabled] = (0, import_react.useState)(false);
  const handleClick = createCallControlHandler(props, async () => {
    if (!hasPermission) {
      await requestPermission();
    } else {
      await camera.toggle();
    }
  });
  return (0, import_jsx_runtime.jsx)(Restricted, { requiredGrants: [OwnCapability.SEND_VIDEO], children: (0, import_jsx_runtime.jsx)(PermissionNotification, { permission: OwnCapability.SEND_VIDEO, isAwaitingApproval: isAwaitingPermission, messageApproved: t("You can now share your video."), messageAwaitingApproval: t("Awaiting for an approval to share your video."), messageRevoked: t("You can no longer share your video."), children: (0, import_jsx_runtime.jsx)(WithTooltip, { title: !hasPermission ? t("You have no permission to share your video") : !hasBrowserPermission ? t("Check your browser video permissions") : !isPublishingVideoAllowed ? t("Video publishing is disabled by the system") : caption || t("Video"), tooltipDisabled, children: (0, import_jsx_runtime.jsxs)(CompositeButton, { active: optionsAwareIsMute, caption, variant: "secondary", disabled: !hasBrowserPermission || !hasPermission || !isPublishingVideoAllowed || !optimisticUpdates && isTogglePending, "data-testid": optionsAwareIsMute ? "video-unmute-button" : "video-mute-button", onClick: handleClick, Menu: Menu2, menuPlacement, menuOffset: 16, ...restCompositeButtonProps, onMenuToggle: (shown) => {
    setTooltipDisabled(shown);
    onMenuToggle?.(shown);
  }, children: [(0, import_jsx_runtime.jsx)(Icon, { icon: optionsAwareIsMute ? "camera-off" : "camera" }), (!hasBrowserPermission || !hasPermission || !isPublishingVideoAllowed) && (0, import_jsx_runtime.jsx)("span", { className: "str-video__no-media-permission", children: "!" }), isPromptingPermission && (0, import_jsx_runtime.jsx)("span", { className: "str-video__pending-permission", title: t("Waiting for permission"), children: "?" })] }) }) }) });
};
var EndCallMenu = (props) => {
  const { onLeave, onEnd } = props;
  const { t } = useI18n();
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__end-call__confirmation", children: [(0, import_jsx_runtime.jsxs)("button", { className: "str-video__button str-video__end-call__leave", type: "button", "data-testid": "leave-call-button", onClick: onLeave, children: [(0, import_jsx_runtime.jsx)(Icon, { className: "str-video__button__icon str-video__end-call__leave-icon", icon: "logout" }), t("Leave call")] }), (0, import_jsx_runtime.jsx)(Restricted, { requiredGrants: [OwnCapability.END_CALL], children: (0, import_jsx_runtime.jsxs)("button", { className: "str-video__button str-video__end-call__end", type: "button", "data-testid": "end-call-for-all-button", onClick: onEnd, children: [(0, import_jsx_runtime.jsx)(Icon, { className: "str-video__button__icon str-video__end-call__end-icon", icon: "call-end" }), t("End call for all")] }) })] });
};
var CancelCallToggleMenuButton = (0, import_react.forwardRef)(function CancelCallToggleMenuButton2({ menuShown }, ref) {
  const { t } = useI18n();
  return (0, import_jsx_runtime.jsx)(WithTooltip, { title: t("Leave call"), tooltipDisabled: menuShown, children: (0, import_jsx_runtime.jsx)(IconButton, { icon: menuShown ? "close" : "call-end", variant: menuShown ? "active" : "danger", "data-testid": "leave-call-button", ref }) });
});
var CancelCallConfirmButton = ({ onClick, onLeave }) => {
  const call = useCall();
  const handleLeave = (0, import_react.useCallback)(async (e) => {
    if (onClick) {
      onClick(e);
    } else if (call) {
      await call.leave();
      onLeave?.();
    }
  }, [onClick, onLeave, call]);
  const handleEndCall = (0, import_react.useCallback)(async (e) => {
    if (onClick) {
      onClick(e);
    } else if (call) {
      await call.endCall();
      onLeave?.();
    }
  }, [onClick, onLeave, call]);
  return (0, import_jsx_runtime.jsx)(MenuToggle, { placement: "top-start", ToggleButton: CancelCallToggleMenuButton, children: (0, import_jsx_runtime.jsx)(EndCallMenu, { onEnd: handleEndCall, onLeave: handleLeave }) });
};
var CancelCallButton = ({ disabled, caption, onClick, onLeave }) => {
  const call = useCall();
  const { t } = useI18n();
  const handleClick = (0, import_react.useCallback)(async (e) => {
    if (onClick) {
      onClick(e);
    } else if (call) {
      await call.leave();
      onLeave?.();
    }
  }, [onClick, onLeave, call]);
  return (0, import_jsx_runtime.jsx)(IconButton, { disabled, icon: "call-end", variant: "danger", title: caption ?? t("Leave call"), "data-testid": "cancel-call-button", onClick: handleClick });
};
var CallControls = ({ onLeave }) => (0, import_jsx_runtime.jsxs)("div", { className: "str-video__call-controls", children: [(0, import_jsx_runtime.jsx)(Restricted, { requiredGrants: [OwnCapability.SEND_AUDIO], children: (0, import_jsx_runtime.jsx)(SpeakingWhileMutedNotification, { children: (0, import_jsx_runtime.jsx)(ToggleAudioPublishingButton, {}) }) }), (0, import_jsx_runtime.jsx)(Restricted, { requiredGrants: [OwnCapability.SEND_VIDEO], children: (0, import_jsx_runtime.jsx)(ToggleVideoPublishingButton, {}) }), (0, import_jsx_runtime.jsx)(Restricted, { requiredGrants: [OwnCapability.CREATE_REACTION], children: (0, import_jsx_runtime.jsx)(ReactionsButton, {}) }), (0, import_jsx_runtime.jsx)(Restricted, { requiredGrants: [OwnCapability.SCREENSHARE], children: (0, import_jsx_runtime.jsx)(ScreenShareButton, {}) }), (0, import_jsx_runtime.jsx)(Restricted, { requiredGrants: [
  OwnCapability.START_RECORD_CALL,
  OwnCapability.STOP_RECORD_CALL
], children: (0, import_jsx_runtime.jsx)(RecordCallButton, {}) }), (0, import_jsx_runtime.jsx)(CancelCallButton, { onLeave })] });
var CallStatsLatencyChart = (0, import_react.lazy)(() => import("./latency-chart-Bj5OSYzg.es-QQG7P463.js"));
var Status;
(function(Status2) {
  Status2["GOOD"] = "Good";
  Status2["OK"] = "Ok";
  Status2["BAD"] = "Bad";
})(Status || (Status = {}));
var CallStats = (props) => {
  const { latencyLowBound = 75, latencyHighBound = 400, audioJitterLowBound = 10, audioJitterHighBound = 30, videoJitterLowBound = 20, videoJitterHighBound = 50, showCodecInfo = false, LatencyChartSuspenseFallback = null } = props;
  const [latencyBuffer, setLatencyBuffer] = (0, import_react.useState)(() => {
    const now = Date.now();
    return Array.from({ length: 20 }, (_, i) => ({ x: now + i, y: 0 }));
  });
  const { t } = useI18n();
  const [publishBitrate, setPublishBitrate] = (0, import_react.useState)("-");
  const [subscribeBitrate, setSubscribeBitrate] = (0, import_react.useState)("-");
  const [publishAudioBitrate, setPublishAudioBitrate] = (0, import_react.useState)("-");
  const [subscribeAudioBitrate, setSubscribeAudioBitrate] = (0, import_react.useState)("-");
  const previousStats = (0, import_react.useRef)(void 0);
  const { useCallStatsReport } = useCallStateHooks();
  const callStatsReport = useCallStatsReport();
  (0, import_react.useEffect)(() => {
    if (!callStatsReport)
      return;
    if (!previousStats.current) {
      previousStats.current = callStatsReport;
      return;
    }
    const previousCallStatsReport = previousStats.current;
    setPublishBitrate(() => {
      return calculatePublishBitrate(previousCallStatsReport, callStatsReport);
    });
    setSubscribeBitrate(() => {
      return calculateSubscribeBitrate(previousCallStatsReport, callStatsReport);
    });
    setPublishAudioBitrate(() => {
      return calculatePublishAudioBitrate(previousCallStatsReport, callStatsReport);
    });
    setSubscribeAudioBitrate(() => {
      return calculateSubscribeAudioBitrate(previousCallStatsReport, callStatsReport);
    });
    setLatencyBuffer((latencyBuf) => {
      const newLatencyBuffer = latencyBuf.slice(-19);
      newLatencyBuffer.push({
        x: callStatsReport.timestamp,
        y: callStatsReport.publisherStats.averageRoundTripTimeInMs || callStatsReport.publisherAudioStats.averageRoundTripTimeInMs
      });
      return newLatencyBuffer;
    });
    previousStats.current = callStatsReport;
  }, [callStatsReport]);
  const latencyComparison = {
    lowBound: latencyLowBound,
    highBound: latencyHighBound,
    value: callStatsReport?.publisherStats.averageRoundTripTimeInMs || 0
  };
  const audioJitterComparison = {
    lowBound: audioJitterLowBound,
    highBound: audioJitterHighBound
  };
  const videoJitterComparison = {
    lowBound: videoJitterLowBound,
    highBound: videoJitterHighBound
  };
  return (0, import_jsx_runtime.jsx)("div", { className: "str-video__call-stats", children: callStatsReport && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsxs)("div", { className: "str-video__call-stats__header", children: [(0, import_jsx_runtime.jsxs)("h3", { className: "str-video__call-stats__heading", children: [(0, import_jsx_runtime.jsx)(Icon, { className: "str-video__call-stats__icon", icon: "call-latency" }), t("Call Latency")] }), (0, import_jsx_runtime.jsx)("p", { className: "str-video__call-stats__description", children: t("Very high latency values may reduce call quality, cause lag, and make the call less enjoyable.") })] }), (0, import_jsx_runtime.jsx)("div", { className: "str-video__call-stats__latencychart", children: (0, import_jsx_runtime.jsx)(import_react.Suspense, { fallback: LatencyChartSuspenseFallback, children: (0, import_jsx_runtime.jsx)(CallStatsLatencyChart, { values: latencyBuffer }) }) }), (0, import_jsx_runtime.jsxs)("div", { className: "str-video__call-stats__header", children: [(0, import_jsx_runtime.jsxs)("h3", { className: "str-video__call-stats__heading", children: [(0, import_jsx_runtime.jsx)(Icon, { className: "str-video__call-stats__icon", icon: "network-quality" }), t("Video performance")] }), (0, import_jsx_runtime.jsx)("p", { className: "str-video__call-stats__description", children: t("Review the key data points below to assess call performance") })] }), (0, import_jsx_runtime.jsxs)("div", { className: "str-video__call-stats__card-container", children: [(0, import_jsx_runtime.jsx)(StatCard, { label: t("Region"), value: callStatsReport.datacenter }), (0, import_jsx_runtime.jsx)(StatCard, { label: t("Latency"), value: `${callStatsReport.publisherStats.averageRoundTripTimeInMs} ms.`, comparison: latencyComparison }), (0, import_jsx_runtime.jsx)(StatCard, { label: t("Receive jitter"), value: `${callStatsReport.subscriberStats.averageJitterInMs} ms.`, comparison: {
    ...videoJitterComparison,
    value: callStatsReport.subscriberStats.averageJitterInMs
  } }), (0, import_jsx_runtime.jsx)(StatCard, { label: t("Publish jitter"), value: `${callStatsReport.publisherStats.averageJitterInMs} ms.`, comparison: {
    ...videoJitterComparison,
    value: callStatsReport.publisherStats.averageJitterInMs
  } }), (0, import_jsx_runtime.jsx)(StatCard, { label: `${t("Publish resolution")}${showCodecInfo ? formatCodec(callStatsReport) : ""}`, value: toFrameSize(callStatsReport.publisherStats) }), (0, import_jsx_runtime.jsx)(StatCard, { label: t("Publish quality drop reason"), value: callStatsReport.publisherStats.qualityLimitationReasons }), (0, import_jsx_runtime.jsx)(StatCard, { label: t("Receiving resolution"), value: toFrameSize(callStatsReport.subscriberStats) }), (0, import_jsx_runtime.jsx)(StatCard, { label: t("Receive quality drop reason"), value: callStatsReport.subscriberStats.qualityLimitationReasons }), (0, import_jsx_runtime.jsx)(StatCard, { label: t("Publish bitrate"), value: publishBitrate }), (0, import_jsx_runtime.jsx)(StatCard, { label: t("Receiving bitrate"), value: subscribeBitrate })] }), (0, import_jsx_runtime.jsxs)("div", { className: "str-video__call-stats__header", children: [(0, import_jsx_runtime.jsxs)("h3", { className: "str-video__call-stats__heading", children: [(0, import_jsx_runtime.jsx)(Icon, { className: "str-video__call-stats__icon", icon: "mic" }), t("Audio Performance")] }), (0, import_jsx_runtime.jsx)("p", { className: "str-video__call-stats__description", children: t("Review the key audio data points below to assess audio performance") })] }), (0, import_jsx_runtime.jsxs)("div", { className: "str-video__call-stats__card-container", children: [(0, import_jsx_runtime.jsx)(StatCard, { label: t("Latency"), value: `${callStatsReport.publisherAudioStats.averageRoundTripTimeInMs} ms.`, comparison: latencyComparison }), (0, import_jsx_runtime.jsx)(StatCard, { label: t("Audio codec"), value: formatAudioCodec(callStatsReport) }), (0, import_jsx_runtime.jsx)(StatCard, { label: t("Audio bitrate (publish)"), value: publishAudioBitrate }), (0, import_jsx_runtime.jsx)(StatCard, { label: t("Audio bitrate (receive)"), value: subscribeAudioBitrate }), (0, import_jsx_runtime.jsx)(StatCard, { label: t("Audio jitter (publish)"), value: `${callStatsReport.publisherAudioStats.averageJitterInMs} ms.`, comparison: {
    ...audioJitterComparison,
    value: callStatsReport.publisherAudioStats.averageJitterInMs
  } }), (0, import_jsx_runtime.jsx)(StatCard, { label: t("Audio jitter (receive)"), value: `${callStatsReport.subscriberAudioStats.averageJitterInMs} ms.`, comparison: {
    ...audioJitterComparison,
    value: callStatsReport.subscriberAudioStats.averageJitterInMs
  } })] })] }) });
};
var StatCardExplanation = (props) => {
  const { description } = props;
  const [isOpen, setIsOpen] = (0, import_react.useState)(false);
  const { refs, floatingStyles, context } = useFloating({
    open: isOpen,
    onOpenChange: setIsOpen
  });
  const hover = useHover(context);
  const { getReferenceProps, getFloatingProps } = useInteractions([hover]);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("div", { className: "str-video__call-explanation", ref: refs.setReference, ...getReferenceProps(), children: (0, import_jsx_runtime.jsx)(Icon, { className: "str-video__call-explanation__icon", icon: "info" }) }), isOpen && (0, import_jsx_runtime.jsx)("div", { className: "str-video__call-explanation__description", ref: refs.setFloating, style: floatingStyles, ...getFloatingProps(), children: description })] });
};
var StatsTag = (props) => {
  const { children, status } = props;
  return (0, import_jsx_runtime.jsx)("div", { className: clsx_default("str-video__call-stats__tag", {
    "str-video__call-stats__tag--good": status === Status.GOOD,
    "str-video__call-stats__tag--ok": status === Status.OK,
    "str-video__call-stats__tag--bad": status === Status.BAD
  }), children: (0, import_jsx_runtime.jsx)("div", { className: "str-video__call-stats__tag__text", children }) });
};
var StatCard = (props) => {
  const { label, value, description, comparison } = props;
  const { t } = useI18n();
  const status = comparison ? toStatus(comparison) : void 0;
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__call-stats__card", children: [(0, import_jsx_runtime.jsxs)("div", { className: "str-video__call-stats__card-content", children: [(0, import_jsx_runtime.jsxs)("div", { className: "str-video__call-stats__card-label", children: [label, description && (0, import_jsx_runtime.jsx)(StatCardExplanation, { description })] }), (0, import_jsx_runtime.jsx)("div", { className: "str-video__call-stats__card-value", children: value })] }), status && (0, import_jsx_runtime.jsx)(StatsTag, { status, children: t(status) })] });
};
var toStatus = (config) => {
  const { value, lowBound, highBound } = config;
  if (value <= lowBound)
    return Status.GOOD;
  if (value >= lowBound && value <= highBound)
    return Status.OK;
  if (value >= highBound)
    return Status.BAD;
  return Status.GOOD;
};
var toFrameSize = (stats) => {
  const { highestFrameWidth: w, highestFrameHeight: h, highestFramesPerSecond: fps } = stats;
  let size2 = `-`;
  if (w && h) {
    size2 = `${w}x${h}`;
    if (fps) {
      size2 += `@${fps}fps.`;
    }
  }
  return size2;
};
var formatCodec = (callStatsReport) => {
  const { codecPerTrackType } = callStatsReport.publisherStats;
  if (!codecPerTrackType || !codecPerTrackType[models.TrackType.VIDEO]) {
    return "";
  }
  const [, name2] = codecPerTrackType[models.TrackType.VIDEO].split("/");
  return name2 ? ` (${name2})` : "";
};
var formatAudioCodec = (callStatsReport) => {
  const { codecPerTrackType } = callStatsReport.publisherAudioStats;
  if (!codecPerTrackType || !codecPerTrackType[models.TrackType.AUDIO]) {
    return "";
  }
  const [, name2] = codecPerTrackType[models.TrackType.AUDIO].split("/");
  return name2 ?? "";
};
var calculatePublishBitrate = (previousCallStatsReport, callStatsReport) => {
  const { publisherStats: { totalBytesSent: previousTotalBytesSent, timestamp: previousTimestamp } } = previousCallStatsReport;
  const { publisherStats: { totalBytesSent, timestamp } } = callStatsReport;
  const bytesSent = totalBytesSent - previousTotalBytesSent;
  const timeElapsed = timestamp - previousTimestamp;
  return `${(bytesSent * 8 / timeElapsed).toFixed(2)} kbps`;
};
var calculateSubscribeBitrate = (previousCallStatsReport, callStatsReport) => {
  const { subscriberStats: { totalBytesReceived: previousTotalBytesReceived, timestamp: previousTimestamp } } = previousCallStatsReport;
  const { subscriberStats: { totalBytesReceived, timestamp } } = callStatsReport;
  const bytesReceived = totalBytesReceived - previousTotalBytesReceived;
  const timeElapsed = timestamp - previousTimestamp;
  return `${(bytesReceived * 8 / timeElapsed).toFixed(2)} kbps`;
};
var calculatePublishAudioBitrate = (previousCallStatsReport, callStatsReport) => {
  const previousAudioStats = previousCallStatsReport.publisherAudioStats;
  const audioStats = callStatsReport.publisherAudioStats;
  const bytesSent = audioStats.totalBytesSent - previousAudioStats.totalBytesSent;
  const timeElapsed = audioStats.timestamp - previousAudioStats.timestamp;
  return `${(bytesSent * 8 / timeElapsed).toFixed(2)} kbps`;
};
var calculateSubscribeAudioBitrate = (previousCallStatsReport, callStatsReport) => {
  const previousAudioStats = previousCallStatsReport.subscriberAudioStats;
  const audioStats = callStatsReport.subscriberAudioStats;
  const bytesReceived = audioStats.totalBytesReceived - previousAudioStats.totalBytesReceived;
  const timeElapsed = audioStats.timestamp - previousAudioStats.timestamp;
  return `${(bytesReceived * 8 / timeElapsed).toFixed(2)} kbps`;
};
var CallStatsButton = () => (0, import_jsx_runtime.jsx)(MenuToggle, { placement: "top-end", ToggleButton: ToggleMenuButton, children: (0, import_jsx_runtime.jsx)(CallStats, {}) });
var ToggleMenuButton = (0, import_react.forwardRef)(function ToggleMenuButton2(props, ref) {
  const { t } = useI18n();
  const { caption, menuShown } = props;
  return (0, import_jsx_runtime.jsx)(CompositeButton, { ref, active: menuShown, caption, title: caption || t("Statistics"), "data-testid": "stats-button", children: (0, import_jsx_runtime.jsx)(Icon, { icon: "stats" }) });
});
var ToggleAudioOutputButton = (props) => {
  const { t } = useI18n();
  const { caption, Menu: Menu2 = DeviceSelectorAudioOutput, menuPlacement = "top", onMenuToggle } = props;
  const [tooltipDisabled, setTooltipDisabled] = (0, import_react.useState)(false);
  return (0, import_jsx_runtime.jsx)(WithTooltip, { title: caption || t("Speakers"), tooltipDisabled, children: (0, import_jsx_runtime.jsx)(CompositeButton, { Menu: Menu2, menuPlacement, caption, "data-testid": "audio-output-button", onMenuToggle: (shown) => {
    setTooltipDisabled(shown);
    onMenuToggle?.(shown);
  }, children: (0, import_jsx_runtime.jsx)(Icon, { icon: "speaker" }) }) });
};
var BlockedUserListing = ({ data }) => {
  if (!data.length)
    return null;
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (0, import_jsx_runtime.jsx)("div", { className: "str-video__participant-listing", children: data.map((userId) => (0, import_jsx_runtime.jsx)(BlockedUserListingItem, { userId }, userId)) }) });
};
var BlockedUserListingItem = ({ userId }) => {
  const call = useCall();
  const unblockUserClickHandler = () => {
    if (userId)
      call?.unblockUser(userId);
  };
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__participant-listing-item", children: [(0, import_jsx_runtime.jsx)("div", { className: "str-video__participant-listing-item__display-name", children: userId }), (0, import_jsx_runtime.jsx)(Restricted, { requiredGrants: [OwnCapability.BLOCK_USERS], children: (0, import_jsx_runtime.jsx)(TextButton, { onClick: unblockUserClickHandler, children: "Unblock" }) })] });
};
var CallParticipantListHeader = ({ onClose }) => {
  const { useParticipants, useAnonymousParticipantCount } = useCallStateHooks();
  const participants = useParticipants();
  const anonymousParticipantCount = useAnonymousParticipantCount();
  const { t } = useI18n();
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__participant-list-header", children: [(0, import_jsx_runtime.jsxs)("div", { className: "str-video__participant-list-header__title", children: [t("Participants"), " ", (0, import_jsx_runtime.jsxs)("span", { className: "str-video__participant-list-header__title-count", children: ["[", participants.length, "]"] }), anonymousParticipantCount > 0 && (0, import_jsx_runtime.jsx)("span", { className: "str-video__participant-list-header__title-anonymous", children: t("Anonymous", { count: anonymousParticipantCount }) })] }), (0, import_jsx_runtime.jsx)(IconButton, { onClick: onClose, className: "str-video__participant-list-header__close-button", icon: "close" })] });
};
var CallParticipantListingItem = ({ participant, DisplayName = DefaultDisplayName }) => {
  const isAudioOn = hasAudio(participant);
  const isVideoOn = hasVideo(participant);
  const isPinnedOn = isPinned(participant);
  const { t } = useI18n();
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__participant-listing-item", children: [(0, import_jsx_runtime.jsx)(Avatar, { name: participant.name, imageSrc: participant.image }), (0, import_jsx_runtime.jsx)(DisplayName, { participant }), (0, import_jsx_runtime.jsxs)("div", { className: "str-video__participant-listing-item__media-indicator-group", children: [(0, import_jsx_runtime.jsx)(MediaIndicator, { title: isAudioOn ? t("Microphone on") : t("Microphone off"), className: clsx_default("str-video__participant-listing-item__icon", `str-video__participant-listing-item__icon-${isAudioOn ? "mic" : "mic-off"}`) }), (0, import_jsx_runtime.jsx)(MediaIndicator, { title: isVideoOn ? t("Camera on") : t("Camera off"), className: clsx_default("str-video__participant-listing-item__icon", `str-video__participant-listing-item__icon-${isVideoOn ? "camera" : "camera-off"}`) }), isPinnedOn && (0, import_jsx_runtime.jsx)(MediaIndicator, { title: t("Pinned"), className: clsx_default("str-video__participant-listing-item__icon", "str-video__participant-listing-item__icon-pinned") }), (0, import_jsx_runtime.jsx)(MenuToggle, { placement: "bottom-end", ToggleButton: ToggleButton$2, children: (0, import_jsx_runtime.jsx)(ParticipantViewContext.Provider, { value: { participant, trackType: "none" }, children: (0, import_jsx_runtime.jsx)(ParticipantActionsContextMenu, {}) }) })] })] });
};
var MediaIndicator = (props) => (0, import_jsx_runtime.jsx)(WithTooltip, { ...props });
var DefaultDisplayName = ({ participant }) => {
  const connectedUser = useConnectedUser();
  const { t } = useI18n();
  const meFlag = participant.userId === connectedUser?.id ? t("Me") : "";
  const nameOrId = participant.name || participant.userId || t("Unknown");
  let displayName;
  if (!participant.name) {
    displayName = meFlag || nameOrId || t("Unknown");
  } else if (meFlag) {
    displayName = `${nameOrId} (${meFlag})`;
  } else {
    displayName = nameOrId;
  }
  return (0, import_jsx_runtime.jsx)(WithTooltip, { className: "str-video__participant-listing-item__display-name", title: displayName, children: displayName });
};
var ToggleButton$2 = (0, import_react.forwardRef)(function ToggleButton(props, ref) {
  return (0, import_jsx_runtime.jsx)(IconButton, { enabled: props.menuShown, icon: "ellipsis", ref });
});
var CallParticipantListing = ({ data }) => (0, import_jsx_runtime.jsx)("div", { className: "str-video__participant-listing", children: data.map((participant) => (0, import_jsx_runtime.jsx)(CallParticipantListingItem, { participant }, participant.sessionId)) });
var EmptyParticipantSearchList = () => {
  const { t } = useI18n();
  return (0, import_jsx_runtime.jsx)("div", { className: "str-video__participant-list--empty", children: t("No participants found") });
};
var SearchInput = ({ exitSearch, isActive, ...rest }) => {
  const [inputElement, setInputElement] = (0, import_react.useState)(null);
  (0, import_react.useEffect)(() => {
    if (!inputElement)
      return;
    const handleKeyDown = (e) => {
      if (e.key.toLowerCase() === "escape")
        exitSearch();
    };
    inputElement.addEventListener("keydown", handleKeyDown);
    return () => {
      inputElement.removeEventListener("keydown", handleKeyDown);
    };
  }, [exitSearch, inputElement]);
  return (0, import_jsx_runtime.jsxs)("div", { className: clsx_default("str-video__search-input__container", {
    "str-video__search-input__container--active": isActive
  }), children: [(0, import_jsx_runtime.jsx)("input", { placeholder: "Search", ...rest, ref: setInputElement }), isActive ? (0, import_jsx_runtime.jsx)("button", { className: "str-video__search-input__clear-btn", onClick: exitSearch, children: (0, import_jsx_runtime.jsx)("span", { className: "str-video__search-input__icon--active" }) }) : (0, import_jsx_runtime.jsx)("span", { className: "str-video__search-input__icon" })] });
};
function SearchResults({ EmptySearchResultComponent, LoadingIndicator: LoadingIndicator$1 = LoadingIndicator, searchQueryInProgress, searchResults, SearchResultList }) {
  if (searchQueryInProgress) {
    return (0, import_jsx_runtime.jsx)("div", { className: "str-video__search-results--loading", children: (0, import_jsx_runtime.jsx)(LoadingIndicator$1, {}) });
  }
  if (!searchResults.length) {
    return (0, import_jsx_runtime.jsx)(EmptySearchResultComponent, {});
  }
  return (0, import_jsx_runtime.jsx)(SearchResultList, { data: searchResults });
}
var useSearch = ({ debounceInterval = 200, searchFn, searchQuery = "" }) => {
  const [searchResults, setSearchResults] = (0, import_react.useState)([]);
  const [searchQueryInProgress, setSearchQueryInProgress] = (0, import_react.useState)(false);
  const searchFnRef = (0, import_react.useRef)(searchFn);
  searchFnRef.current = searchFn;
  (0, import_react.useEffect)(() => {
    if (!searchQuery.length) {
      setSearchQueryInProgress(false);
      setSearchResults([]);
      return;
    }
    setSearchQueryInProgress(true);
    const timeout = setTimeout(async () => {
      try {
        const results = await searchFnRef.current(searchQuery);
        setSearchResults(results);
      } catch (error) {
        console.error(error);
      } finally {
        setSearchQueryInProgress(false);
      }
    }, debounceInterval);
    return () => {
      clearTimeout(timeout);
    };
  }, [debounceInterval, searchQuery]);
  return {
    searchQueryInProgress,
    searchResults
  };
};
var UserListTypes = {
  active: "Active users",
  blocked: "Blocked users"
};
var CallParticipantsList = ({ onClose, activeUsersSearchFn, blockedUsersSearchFn, debounceSearchInterval }) => {
  const [searchQuery, setSearchQuery] = (0, import_react.useState)("");
  const [userListType, setUserListType] = (0, import_react.useState)("active");
  const exitSearch = (0, import_react.useCallback)(() => setSearchQuery(""), []);
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__participant-list", children: [(0, import_jsx_runtime.jsx)(CallParticipantListHeader, { onClose }), (0, import_jsx_runtime.jsx)(SearchInput, { value: searchQuery, onChange: ({ currentTarget }) => setSearchQuery(currentTarget.value), exitSearch, isActive: !!searchQuery }), (0, import_jsx_runtime.jsx)(CallParticipantListContentHeader, { userListType, setUserListType }), (0, import_jsx_runtime.jsxs)("div", { className: "str-video__participant-list__content", children: [userListType === "active" && (0, import_jsx_runtime.jsx)(ActiveUsersSearchResults, { searchQuery, activeUsersSearchFn, debounceSearchInterval }), userListType === "blocked" && (0, import_jsx_runtime.jsx)(BlockedUsersSearchResults, { searchQuery, blockedUsersSearchFn, debounceSearchInterval })] })] });
};
var CallParticipantListContentHeader = ({ userListType, setUserListType }) => {
  const call = useCall();
  const { t } = useI18n();
  const muteAll = (0, import_react.useCallback)(() => {
    call?.muteAllUsers("audio");
  }, [call]);
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__participant-list__content-header", children: [(0, import_jsx_runtime.jsx)("div", { className: "str-video__participant-list__content-header-title", children: userListType === "active" && (0, import_jsx_runtime.jsx)(Restricted, { requiredGrants: [OwnCapability.MUTE_USERS], hasPermissionsOnly: true, children: (0, import_jsx_runtime.jsx)(TextButton, { onClick: muteAll, children: t("Mute all") }) }) }), (0, import_jsx_runtime.jsx)(MenuToggle, { placement: "bottom-end", ToggleButton: ToggleButton$1, children: (0, import_jsx_runtime.jsx)(GenericMenu, { children: Object.keys(UserListTypes).map((lt) => (0, import_jsx_runtime.jsx)(GenericMenuButtonItem, { "aria-selected": lt === userListType, onClick: () => setUserListType(lt), children: UserListTypes[lt] }, lt)) }) })] });
};
var ActiveUsersSearchResults = ({ searchQuery, activeUsersSearchFn: activeUsersSearchFnFromProps, debounceSearchInterval }) => {
  const { useParticipants } = useCallStateHooks();
  const participants = useParticipants({ sortBy: name });
  const activeUsersSearchFn = (0, import_react.useCallback)(async (queryString) => {
    const queryRegExp = new RegExp(queryString, "i");
    return participants.filter((p) => p.name.match(queryRegExp));
  }, [participants]);
  const { searchQueryInProgress, searchResults } = useSearch({
    searchFn: activeUsersSearchFnFromProps ?? activeUsersSearchFn,
    debounceInterval: debounceSearchInterval,
    searchQuery
  });
  return (0, import_jsx_runtime.jsx)(SearchResults, { EmptySearchResultComponent: EmptyParticipantSearchList, LoadingIndicator, searchQueryInProgress, searchResults: searchQuery ? searchResults : participants, SearchResultList: CallParticipantListing });
};
var BlockedUsersSearchResults = ({ blockedUsersSearchFn: blockedUsersSearchFnFromProps, debounceSearchInterval, searchQuery }) => {
  const { useCallBlockedUserIds } = useCallStateHooks();
  const blockedUsers = useCallBlockedUserIds();
  const blockedUsersSearchFn = (0, import_react.useCallback)(async (queryString) => {
    const queryRegExp = new RegExp(queryString, "i");
    return blockedUsers.filter((userId) => userId.match(queryRegExp));
  }, [blockedUsers]);
  const { searchQueryInProgress, searchResults } = useSearch({
    searchFn: blockedUsersSearchFnFromProps ?? blockedUsersSearchFn,
    debounceInterval: debounceSearchInterval,
    searchQuery
  });
  return (0, import_jsx_runtime.jsx)(SearchResults, { EmptySearchResultComponent: EmptyParticipantSearchList, LoadingIndicator, searchQueryInProgress, searchResults: searchQuery ? searchResults : blockedUsers, SearchResultList: BlockedUserListing });
};
var ToggleButton$1 = (0, import_react.forwardRef)(function ToggleButton2(props, ref) {
  return (0, import_jsx_runtime.jsx)(IconButton, { enabled: props.menuShown, icon: "filter", ref });
});
var CallPreview = (props) => {
  const { className, style } = props;
  const call = useCall();
  const { useCallThumbnail } = useCallStateHooks();
  const thumbnail = useCallThumbnail();
  const [imageRef, setImageRef] = (0, import_react.useState)(null);
  (0, import_react.useEffect)(() => {
    if (!imageRef || !call)
      return;
    const cleanup = call.bindCallThumbnailElement(imageRef);
    return () => cleanup();
  }, [imageRef, call]);
  if (!thumbnail)
    return null;
  return (0, import_jsx_runtime.jsx)("img", { className: clsx_default("str-video__call-preview", className), style, alt: "Call Preview Thumbnail", ref: setImageRef });
};
var CallRecordingListHeader = ({ callRecordings, onRefresh }) => {
  const { t } = useI18n();
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__call-recording-list__header", children: [(0, import_jsx_runtime.jsxs)("div", { className: "str-video__call-recording-list__title", children: [(0, import_jsx_runtime.jsx)("span", { children: t("Call Recordings") }), callRecordings.length ? (0, import_jsx_runtime.jsxs)("span", { children: ["(", callRecordings.length, ")"] }) : null] }), onRefresh && (0, import_jsx_runtime.jsx)(IconButton, { icon: "refresh", title: t("Refresh"), onClick: onRefresh })] });
};
var dateFormat = (date) => {
  const format = new Date(date);
  return format.toTimeString().split(" ")[0];
};
var CallRecordingListItem = ({ recording }) => {
  return (0, import_jsx_runtime.jsxs)("li", { className: "str-video__call-recording-list__item", children: [(0, import_jsx_runtime.jsx)("div", { className: "str-video__call-recording-list__table-cell str-video__call-recording-list__filename", children: recording.filename }), (0, import_jsx_runtime.jsx)("div", { className: "str-video__call-recording-list__table-cell str-video__call-recording-list__time", children: dateFormat(recording.start_time) }), (0, import_jsx_runtime.jsx)("div", { className: "str-video__call-recording-list__table-cell str-video__call-recording-list__time", children: dateFormat(recording.end_time) }), (0, import_jsx_runtime.jsx)("div", { className: "str-video__call-recording-list__table-cell str-video__call-recording-list__download", children: (0, import_jsx_runtime.jsx)("a", { className: clsx_default("str-video__call-recording-list-item__action-button", "str-video__call-recording-list-item__action-button--download"), role: "button", href: recording.url, download: recording.filename, title: "Download the recording", children: (0, import_jsx_runtime.jsx)(Icon, { icon: "download" }) }) })] });
};
var EmptyCallRecordingListing = () => {
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__call-recording-list__listing str-video__call-recording-list__listing--empty", children: [(0, import_jsx_runtime.jsx)("div", { className: "str-video__call-recording-list__listing--icon-empty" }), (0, import_jsx_runtime.jsx)("p", { className: "str-video__call-recording-list__listing--text-empty", children: "No recordings available" })] });
};
var LoadingCallRecordingListing = ({ callRecordings }) => {
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [callRecordings.map((recording) => (0, import_jsx_runtime.jsx)(CallRecordingListItem, { recording }, recording.filename)), (0, import_jsx_runtime.jsx)(LoadingIndicator, { text: "Recording getting ready" })] });
};
var CallRecordingList = ({ callRecordings, CallRecordingListHeader: CallRecordingListHeader$1 = CallRecordingListHeader, CallRecordingListItem: CallRecordingListItem$1 = CallRecordingListItem, EmptyCallRecordingList = EmptyCallRecordingListing, loading, LoadingCallRecordingList = LoadingCallRecordingListing, onRefresh }) => {
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__call-recording-list", children: [(0, import_jsx_runtime.jsx)(CallRecordingListHeader$1, { callRecordings, onRefresh }), (0, import_jsx_runtime.jsx)("div", { className: "str-video__call-recording-list__listing", children: loading ? (0, import_jsx_runtime.jsx)(LoadingCallRecordingList, { callRecordings }) : callRecordings.length ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("ul", { className: "str-video__call-recording-list__list", children: (0, import_jsx_runtime.jsxs)("li", { className: "str-video__call-recording-list__item", children: [(0, import_jsx_runtime.jsx)("div", { className: "str-video__call-recording-list__filename", children: "Name" }), (0, import_jsx_runtime.jsx)("div", { className: "str-video__call-recording-list__time", children: "Start time" }), (0, import_jsx_runtime.jsx)("div", { className: "str-video__call-recording-list__time", children: "End time" }), (0, import_jsx_runtime.jsx)("div", { className: "str-video__call-recording-list__download" })] }) }), (0, import_jsx_runtime.jsx)("ul", { className: "str-video__call-recording-list__list", children: callRecordings.map((recording) => (0, import_jsx_runtime.jsx)(CallRecordingListItem$1, { recording }, recording.filename)) })] }) : (0, import_jsx_runtime.jsx)(EmptyCallRecordingList, {}) })] });
};
var NoiseCancellationContext = (0, import_react.createContext)(null);
var useNoiseCancellation = () => {
  const context = (0, import_react.useContext)(NoiseCancellationContext);
  if (!context) {
    throw new Error("useNoiseCancellation must be used within a NoiseCancellationProvider");
  }
  return context;
};
var NoiseCancellationProvider = (props) => {
  const { children, noiseCancellation } = props;
  const call = useCall();
  const { useCallSettings, useHasPermissions } = useCallStateHooks();
  const settings = useCallSettings();
  const noiseCancellationAllowed = !!(settings && settings.audio.noise_cancellation && settings.audio.noise_cancellation.mode !== NoiseCancellationSettingsModeEnum.DISABLED);
  const hasCapability = useHasPermissions(OwnCapability.ENABLE_NOISE_CANCELLATION);
  const [isSupportedByBrowser, setIsSupportedByBrowser] = (0, import_react.useState)();
  (0, import_react.useEffect)(() => {
    const result = noiseCancellation.isSupported();
    if (typeof result === "boolean") {
      setIsSupportedByBrowser(result);
    } else {
      result.then((s) => setIsSupportedByBrowser(s)).catch((err) => console.error(`Can't determine if noise cancellation is supported`, err));
    }
  }, [noiseCancellation]);
  const isSupported = isSupportedByBrowser && hasCapability && noiseCancellationAllowed;
  const [isEnabled, setIsEnabled] = (0, import_react.useState)(false);
  const deinit = (0, import_react.useRef)(void 0);
  (0, import_react.useEffect)(() => {
    if (!call || !isSupported)
      return;
    noiseCancellation.isEnabled().then((e) => setIsEnabled(e));
    const unsubscribe = noiseCancellation.on("change", (v) => setIsEnabled(v));
    const init = (deinit.current || Promise.resolve()).then(() => noiseCancellation.init({ tracer: call.tracer })).then(() => call.microphone.enableNoiseCancellation(noiseCancellation)).catch((e) => console.error(`Can't initialize noise cancellation`, e));
    return () => {
      deinit.current = init.then(() => call.microphone.disableNoiseCancellation()).then(() => noiseCancellation.dispose()).then(() => unsubscribe());
    };
  }, [call, isSupported, noiseCancellation]);
  const contextValue = (0, import_react.useMemo)(() => ({
    isSupported,
    isEnabled,
    setSuppressionLevel: (level) => {
      if (!noiseCancellation)
        return;
      noiseCancellation.setSuppressionLevel(level);
    },
    setEnabled: (enabledOrSetter) => {
      if (!noiseCancellation)
        return;
      const enable = typeof enabledOrSetter === "function" ? enabledOrSetter(isEnabled) : enabledOrSetter;
      if (enable) {
        noiseCancellation.enable().catch((err) => {
          console.error("Failed to enable noise cancellation", err);
        });
      } else {
        noiseCancellation.disable().catch((err) => {
          console.error("Failed to disable noise cancellation", err);
        });
      }
    }
  }), [isEnabled, isSupported, noiseCancellation]);
  return (0, import_jsx_runtime.jsx)(NoiseCancellationContext.Provider, { value: contextValue, children });
};
var RingingCallControls = () => {
  const call = useCall();
  const { useCallCallingState } = useCallStateHooks();
  const callCallingState = useCallCallingState();
  if (!call)
    return null;
  const buttonsDisabled = callCallingState !== CallingState.RINGING;
  return (0, import_jsx_runtime.jsx)("div", { className: "str-video__pending-call-controls", children: call.isCreatedByMe ? (0, import_jsx_runtime.jsx)(CancelCallButton, { disabled: buttonsDisabled }) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(AcceptCallButton, { disabled: buttonsDisabled }), (0, import_jsx_runtime.jsx)(CancelCallButton, { onClick: () => {
    const reason = call.isCreatedByMe ? "cancel" : "decline";
    call.leave({ reject: true, reason });
  }, disabled: buttonsDisabled })] }) });
};
var CALLING_STATE_TO_LABEL = {
  [CallingState.JOINING]: "Joining",
  [CallingState.RINGING]: "Ringing",
  [CallingState.MIGRATING]: "Migrating",
  [CallingState.RECONNECTING]: "Re-connecting",
  [CallingState.RECONNECTING_FAILED]: "Failed",
  [CallingState.OFFLINE]: "No internet connection",
  [CallingState.IDLE]: "",
  [CallingState.UNKNOWN]: "",
  [CallingState.JOINED]: "Joined",
  [CallingState.LEFT]: "Left call"
};
var RingingCall = (props) => {
  const { includeSelf = false, totalMembersToShow = 3 } = props;
  const call = useCall();
  const { t } = useI18n();
  const { useCallCallingState, useCallMembers } = useCallStateHooks();
  const callingState = useCallCallingState();
  const members = useCallMembers();
  const connectedUser = useConnectedUser();
  if (!call)
    return null;
  const membersToShow = (members || []).slice(0, totalMembersToShow).map(({ user }) => user).filter((user) => user.id !== connectedUser?.id || includeSelf);
  if (includeSelf && !membersToShow.find((user) => user.id === connectedUser?.id)) {
    const self = members.find(({ user }) => user.id === connectedUser?.id);
    if (self) {
      membersToShow.splice(0, 1, self.user);
    }
  }
  const callingStateLabel = CALLING_STATE_TO_LABEL[callingState];
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__call-panel str-video__call-panel--ringing", children: [(0, import_jsx_runtime.jsx)("div", { className: "str-video__call-panel__members-list", children: membersToShow.map((user) => (0, import_jsx_runtime.jsxs)("div", { className: "str-video__call-panel__member-box", children: [(0, import_jsx_runtime.jsx)(Avatar, { name: user.name, imageSrc: user.image }), user.name && (0, import_jsx_runtime.jsx)("div", { className: "str-video__member_details", children: (0, import_jsx_runtime.jsx)("span", { className: "str-video__member_name", children: user.name }) })] }, user.id)) }), callingStateLabel && (0, import_jsx_runtime.jsx)("div", { className: "str-video__call-panel__calling-state-label", children: t(callingStateLabel) }), [CallingState.RINGING, CallingState.JOINING].includes(callingState) && (0, import_jsx_runtime.jsx)(RingingCallControls, {})] });
};
var byNameOrId = (a, b) => {
  if (a.name && b.name && a.name < b.name)
    return -1;
  if (a.name && b.name && a.name > b.name)
    return 1;
  if (a.id < b.id)
    return -1;
  if (a.id > b.id)
    return 1;
  return 0;
};
var PermissionRequests = () => {
  const call = useCall();
  const { useLocalParticipant, useHasPermissions } = useCallStateHooks();
  const localParticipant = useLocalParticipant();
  const [expanded, setExpanded] = (0, import_react.useState)(false);
  const [permissionRequests, setPermissionRequests] = (0, import_react.useState)([]);
  const canUpdateCallPermissions = useHasPermissions(OwnCapability.UPDATE_CALL_PERMISSIONS);
  const localUserId = localParticipant?.userId;
  (0, import_react.useEffect)(() => {
    if (!call || !canUpdateCallPermissions)
      return;
    return call.on("call.permission_request", (event) => {
      if (event.user.id !== localUserId) {
        setPermissionRequests((requests) => [...requests, event].sort((a, b) => byNameOrId(a.user, b.user)));
      }
    });
  }, [call, canUpdateCallPermissions, localUserId]);
  const handleUpdatePermission = (request, type) => {
    return async () => {
      const { user, permissions } = request;
      switch (type) {
        case "grant":
          await call?.grantPermissions(user.id, permissions);
          break;
        case "revoke":
          await call?.revokePermissions(user.id, permissions);
          break;
      }
      setPermissionRequests((requests) => requests.filter((r) => r !== request));
    };
  };
  const { refs, x, y, strategy } = useFloatingUIPreset({
    placement: "bottom",
    strategy: "absolute"
  });
  if (permissionRequests.length === 0)
    return null;
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__permission-requests", ref: refs.setReference, children: [(0, import_jsx_runtime.jsxs)("div", { className: "str-video__permission-requests__notification", children: [(0, import_jsx_runtime.jsxs)("span", { className: "str-video__permission-requests__notification__message", children: [permissionRequests.length, " pending permission requests"] }), (0, import_jsx_runtime.jsx)(Button, { type: "button", onClick: () => {
    setExpanded((e) => !e);
  }, children: expanded ? "Hide requests" : "Show requests" })] }), expanded && (0, import_jsx_runtime.jsx)(PermissionRequestList, { ref: refs.setFloating, style: {
    position: strategy,
    top: y ?? 0,
    left: x ?? 0,
    overflowY: "auto"
  }, permissionRequests, handleUpdatePermission })] });
};
var PermissionRequestList = (0, import_react.forwardRef)(function PermissionRequestList2(props, ref) {
  const { permissionRequests, handleUpdatePermission, ...rest } = props;
  const { t } = useI18n();
  return (0, import_jsx_runtime.jsx)("div", { className: "str-video__permission-requests-list", ref, ...rest, children: permissionRequests.map((request, reqIndex) => {
    const { user, permissions } = request;
    return (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: permissions.map((permission) => (0, import_jsx_runtime.jsxs)("div", { className: "str-video__permission-request", children: [(0, import_jsx_runtime.jsx)("div", { className: "str-video__permission-request__message", children: messageForPermission(user.name || user.id, permission, t) }), (0, import_jsx_runtime.jsx)(Button, { className: "str-video__permission-request__button--allow", type: "button", onClick: handleUpdatePermission(request, "grant"), children: t("Allow") }), (0, import_jsx_runtime.jsx)(Button, { className: "str-video__permission-request__button--reject", type: "button", onClick: handleUpdatePermission(request, "revoke"), children: t("Revoke") }), (0, import_jsx_runtime.jsx)(Button, { className: "str-video__permission-request__button--reject", type: "button", onClick: handleUpdatePermission(request, "dismiss"), children: t("Dismiss") })] }, permission)) }, `${user.id}/${reqIndex}`);
  }) });
});
var Button = (props) => {
  const { className, ...rest } = props;
  return (0, import_jsx_runtime.jsx)("button", { className: clsx_default("str-video__permission-request__button", className), ...rest });
};
var messageForPermission = (userName, permission, t) => {
  switch (permission) {
    case OwnCapability.SEND_AUDIO:
      return t("{{ userName }} is requesting to speak", { userName });
    case OwnCapability.SEND_VIDEO:
      return t("{{ userName }} is requesting to share their camera", {
        userName
      });
    case OwnCapability.SCREENSHARE:
      return t("{{ userName }} is requesting to present their screen", {
        userName
      });
    default:
      return t("{{ userName }} is requesting permission: {{ permission }}", {
        userName,
        permission
      });
  }
};
var StreamTheme = ({ as: Component = "div", className, children, ...props }) => {
  return (0, import_jsx_runtime.jsx)(Component, { ...props, className: clsx_default("str-video", className), children });
};
var DefaultDisabledVideoPreview = () => {
  const { t } = useI18n();
  return (0, import_jsx_runtime.jsx)("div", { className: "str_video__video-preview__disabled-video-preview", children: t("Video is disabled") });
};
var DefaultNoCameraPreview = () => {
  const { t } = useI18n();
  return (0, import_jsx_runtime.jsx)("div", { className: "str_video__video-preview__no-camera-preview", children: t("No camera found") });
};
var VideoPreview = ({ className, mirror = true, DisabledVideoPreview = DefaultDisabledVideoPreview, NoCameraPreview = DefaultNoCameraPreview, StartingCameraPreview = LoadingIndicator }) => {
  const { useCameraState } = useCallStateHooks();
  const { devices, status, isMute, mediaStream } = useCameraState();
  let contents;
  if (isMute && devices?.length === 0) {
    contents = (0, import_jsx_runtime.jsx)(NoCameraPreview, {});
  } else if (status === "enabled") {
    const loading = !mediaStream;
    contents = (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [mediaStream && (0, import_jsx_runtime.jsx)(BaseVideo, { stream: mediaStream, className: clsx_default("str-video__video-preview", {
      "str-video__video-preview--mirror": mirror,
      "str-video__video-preview--loading": loading
    }) }), loading && (0, import_jsx_runtime.jsx)(StartingCameraPreview, {})] });
  } else {
    contents = (0, import_jsx_runtime.jsx)(DisabledVideoPreview, {});
  }
  return (0, import_jsx_runtime.jsx)("div", { className: clsx_default("str-video__video-preview-container", className), children: contents });
};
var ToggleButton3 = (0, import_react.forwardRef)(function ToggleButton4(props, ref) {
  return (0, import_jsx_runtime.jsx)(IconButton, { enabled: props.menuShown, icon: "ellipsis", ref });
});
var DefaultScreenShareOverlay = () => {
  const call = useCall();
  const { t } = useI18n();
  const stopScreenShare = () => {
    call?.screenShare.disable().catch((err) => {
      console.error("Failed to stop screen sharing:", err);
    });
  };
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__screen-share-overlay", children: [(0, import_jsx_runtime.jsx)(Icon, { icon: "screen-share-off" }), (0, import_jsx_runtime.jsx)("span", { className: "str-video__screen-share-overlay__title", children: t("You are presenting your screen") }), (0, import_jsx_runtime.jsxs)("button", { onClick: stopScreenShare, type: "button", className: "str-video__screen-share-overlay__button", children: [(0, import_jsx_runtime.jsx)(Icon, { icon: "close" }), " ", t("Stop Screen Sharing")] })] });
};
var DefaultParticipantViewUI = ({ indicatorsVisible = true, menuPlacement = "bottom-start", showMenuButton = true, ParticipantActionsContextMenu: ParticipantActionsContextMenu$1 = ParticipantActionsContextMenu }) => {
  const { participant, trackType } = useParticipantViewContext();
  const isScreenSharing = hasScreenShare(participant);
  if (participant.isLocalParticipant && isScreenSharing && trackType === "screenShareTrack") {
    return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(DefaultScreenShareOverlay, {}), (0, import_jsx_runtime.jsx)(ParticipantDetails, { indicatorsVisible })] });
  }
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [showMenuButton && (0, import_jsx_runtime.jsx)(MenuToggle, { strategy: "fixed", placement: menuPlacement, ToggleButton: ToggleButton3, children: (0, import_jsx_runtime.jsx)(ParticipantActionsContextMenu$1, {}) }), (0, import_jsx_runtime.jsx)(Reaction, { participant }), (0, import_jsx_runtime.jsx)(ParticipantDetails, { indicatorsVisible })] });
};
var ParticipantDetails = ({ indicatorsVisible = true }) => {
  const { participant, trackType } = useParticipantViewContext();
  const { isLocalParticipant, connectionQuality, pin, sessionId, name: name2, userId } = participant;
  const call = useCall();
  const { t } = useI18n();
  const connectionQualityAsString = !!connectionQuality && models.ConnectionQuality[connectionQuality].toLowerCase();
  const hasAudioTrack = hasAudio(participant);
  const hasVideoTrack = hasVideo(participant);
  const canUnpin = !!pin && pin.isLocalPin;
  const isTrackPaused = trackType !== "none" ? hasPausedTrack(participant, trackType) : false;
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("div", { className: "str-video__participant-details", children: (0, import_jsx_runtime.jsxs)("span", { className: "str-video__participant-details__name", children: [name2 || userId, indicatorsVisible && !hasAudioTrack && (0, import_jsx_runtime.jsx)("span", { className: "str-video__participant-details__name--audio-muted" }), indicatorsVisible && !hasVideoTrack && (0, import_jsx_runtime.jsx)("span", { className: "str-video__participant-details__name--video-muted" }), indicatorsVisible && isTrackPaused && (0, import_jsx_runtime.jsx)("span", { title: t("Video paused due to insufficient bandwidth"), className: "str-video__participant-details__name--track-paused" }), indicatorsVisible && canUnpin && // TODO: remove this monstrosity once we have a proper design
  (0, import_jsx_runtime.jsx)("span", { title: t("Unpin"), onClick: () => call?.unpin(sessionId), className: "str-video__participant-details__name--pinned" }), indicatorsVisible && (0, import_jsx_runtime.jsx)(SpeechIndicator, {})] }) }), indicatorsVisible && (0, import_jsx_runtime.jsx)(Notification, { isVisible: isLocalParticipant && connectionQuality === models.ConnectionQuality.POOR, message: t("Poor connection quality"), children: connectionQualityAsString && (0, import_jsx_runtime.jsx)("span", { className: clsx_default("str-video__participant-details__connection-quality", `str-video__participant-details__connection-quality--${connectionQualityAsString}`), title: connectionQualityAsString }) })] });
};
var SpeechIndicator = () => {
  const { participant } = useParticipantViewContext();
  const { isSpeaking, isDominantSpeaker } = participant;
  return (0, import_jsx_runtime.jsxs)("span", { className: clsx_default("str-video__speech-indicator", isSpeaking && "str-video__speech-indicator--speaking", isDominantSpeaker && "str-video__speech-indicator--dominant"), children: [(0, import_jsx_runtime.jsx)("span", { className: "str-video__speech-indicator__bar" }), (0, import_jsx_runtime.jsx)("span", { className: "str-video__speech-indicator__bar" }), (0, import_jsx_runtime.jsx)("span", { className: "str-video__speech-indicator__bar" })] });
};
var ParticipantView = (0, import_react.forwardRef)(function ParticipantView2({ participant, trackType = "videoTrack", mirror, muteAudio, refs: { setVideoElement, setVideoPlaceholderElement } = {}, className, VideoPlaceholder, PictureInPicturePlaceholder, ParticipantViewUI = DefaultParticipantViewUI }, ref) {
  const { isLocalParticipant, isSpeaking, isDominantSpeaker, sessionId } = participant;
  const hasAudioTrack = hasAudio(participant);
  const hasVideoTrack = hasVideo(participant);
  const hasScreenShareAudioTrack = hasScreenShareAudio(participant);
  const [trackedElement, setTrackedElement] = (0, import_react.useState)(null);
  const [contextVideoElement, setContextVideoElement] = (0, import_react.useState)(null);
  const [contextVideoPlaceholderElement, setContextVideoPlaceholderElement] = (0, import_react.useState)(null);
  useTrackElementVisibility({
    sessionId,
    trackedElement,
    trackType
  });
  const { useIncomingVideoSettings } = useCallStateHooks();
  const { isParticipantVideoEnabled } = useIncomingVideoSettings();
  const participantViewContextValue = (0, import_react.useMemo)(() => ({
    participant,
    participantViewElement: trackedElement,
    videoElement: contextVideoElement,
    videoPlaceholderElement: contextVideoPlaceholderElement,
    trackType
  }), [
    contextVideoElement,
    contextVideoPlaceholderElement,
    participant,
    trackedElement,
    trackType
  ]);
  const videoRefs = (0, import_react.useMemo)(() => ({
    setVideoElement: (element) => {
      setVideoElement?.(element);
      setContextVideoElement(element);
    },
    setVideoPlaceholderElement: (element) => {
      setVideoPlaceholderElement?.(element);
      setContextVideoPlaceholderElement(element);
    }
  }), [setVideoElement, setVideoPlaceholderElement]);
  return (0, import_jsx_runtime.jsx)("div", { "data-testid": "participant-view", ref: (element) => {
    applyElementToRef(ref, element);
    setTrackedElement(element);
  }, className: clsx_default("str-video__participant-view", isDominantSpeaker && "str-video__participant-view--dominant-speaker", isSpeaking && "str-video__participant-view--speaking", !hasVideoTrack && "str-video__participant-view--no-video", !hasAudioTrack && "str-video__participant-view--no-audio", className), children: (0, import_jsx_runtime.jsxs)(ParticipantViewContext.Provider, { value: participantViewContextValue, children: [!isLocalParticipant && !muteAudio && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [hasAudioTrack && (0, import_jsx_runtime.jsx)(Audio, { participant, trackType: "audioTrack" }), hasScreenShareAudioTrack && (0, import_jsx_runtime.jsx)(Audio, { participant, trackType: "screenShareAudioTrack" })] }), (0, import_jsx_runtime.jsx)(Video$1, { VideoPlaceholder, PictureInPicturePlaceholder, participant, trackType, refs: videoRefs, enabled: isLocalParticipant || trackType !== "videoTrack" || isParticipantVideoEnabled(participant.sessionId), mirror, autoPlay: true }), isComponentType(ParticipantViewUI) ? (0, import_jsx_runtime.jsx)(ParticipantViewUI, {}) : ParticipantViewUI] }) });
});
ParticipantView.displayName = "ParticipantView";
var StreamCall = StreamCallProvider;
StreamCall.displayName = "StreamCall";
var Joining = "Joining";
var Mic = "Mic";
var Ringing = "Ringing";
var Speakers = "Speakers";
var Video = "Video";
var Live = "Live";
var Reactions = "Reactions";
var Statistics = "Statistics";
var Invite = "Invite";
var Join = "Join";
var You = "You";
var Me = "Me";
var Unknown = "Unknown";
var Default = "Default";
var Refresh = "Refresh";
var Allow = "Allow";
var Revoke = "Revoke";
var Dismiss = "Dismiss";
var Pinned = "Pinned";
var Unpin = "Unpin";
var Pin = "Pin";
var Block = "Block";
var Kick = "Kick";
var Enter = "Enter";
var Leave = "Leave";
var Participants = "Participants";
var Anonymous = ", and ({{ count }}) anonymous";
var en = {
  Joining,
  Mic,
  "No internet connection": "No internet connection",
  "Re-connecting": "Re-connecting",
  Ringing,
  "Screen Share": "Screen Share",
  "Select a Camera": "Select a Camera",
  "Select a Mic": "Select a Mic",
  "Select Speakers": "Select Speakers",
  Speakers,
  Video,
  "You are muted. Unmute to speak.": "You are muted. Unmute to speak.",
  "Background filters performance is degraded. Consider disabling filters for better performance.": "Background filters performance is degraded. Consider disabling filters for better performance.",
  Live,
  "Livestream starts soon": "Livestream starts soon",
  "Livestream starts at {{ startsAt }}": "Livestream starts at {{ startsAt, datetime }}",
  "{{ count }} participants joined early_one": "{{ count }} participant joined early",
  "{{ count }} participants joined early_other": "{{ count }} participants joined early",
  "You can now speak.": "You can now speak.",
  "Awaiting for an approval to speak.": "Awaiting for an approval to speak.",
  "You can no longer speak.": "You can no longer speak.",
  "You can now share your video.": "You can now share your video.",
  "Awaiting for an approval to share your video.": "Awaiting for an approval to share your video.",
  "You can no longer share your video.": "You can no longer share your video.",
  "Waiting for recording to stop...": "Waiting for recording to stop...",
  "Waiting for recording to start...": "Waiting for recording to start...",
  "Record call": "Record call",
  Reactions,
  Statistics,
  "You can now share your screen.": "You can now share your screen.",
  "Awaiting for an approval to share screen.": "Awaiting for an approval to share screen.",
  "You can no longer share your screen.": "You can no longer share your screen.",
  "Share screen": "Share screen",
  "Incoming Call...": "Incoming Call...",
  "Calling...": "Calling...",
  "Mute All": "Mute All",
  Invite,
  Join,
  You,
  Me,
  Unknown,
  "Toggle device menu": "Toggle device menu",
  Default,
  "Call Recordings": "Call Recordings",
  Refresh,
  "Check your browser video permissions": "Check your browser video permissions",
  "Video publishing is disabled by the system": "Video publishing is disabled by the system",
  "You have no permission to share your video": "You have no permission to share your video",
  "You have no permission to share your audio": "You have no permission to share your audio",
  "You are presenting your screen": "You are presenting your screen",
  "Stop Screen Sharing": "Stop Screen Sharing",
  Allow,
  Revoke,
  Dismiss,
  "Microphone on": "Microphone on",
  "Microphone off": "Microphone off",
  "Camera on": "Camera on",
  "Camera off": "Camera off",
  "No camera found": "No camera found",
  "Video is disabled": "Video is disabled",
  Pinned,
  Unpin,
  Pin,
  "Pin for everyone": "Pin for everyone",
  "Unpin for everyone": "Unpin for everyone",
  Block,
  Kick,
  "Turn off video": "Turn off video",
  "Turn off screen share": "Turn off screen share",
  "Mute audio": "Mute audio",
  "Mute screen share audio": "Mute screen share audio",
  "Allow audio": "Allow audio",
  "Allow video": "Allow video",
  "Allow screen sharing": "Allow screen sharing",
  "Disable audio": "Disable audio",
  "Disable video": "Disable video",
  "Disable screen sharing": "Disable screen sharing",
  Enter,
  Leave,
  "Leave call": "Leave call",
  "End call for all": "End call for all",
  "{{ direction }} fullscreen": "{{ direction }} fullscreen",
  "{{ direction }} picture-in-picture": "{{ direction }} picture-in-picture",
  "Dominant Speaker": "Dominant Speaker",
  "Poor connection quality": "Poor connection quality. Please check your internet connection.",
  "Video paused due to insufficient bandwidth": "Video paused due to insufficient bandwidth",
  Participants,
  Anonymous,
  "No participants found": "No participants found",
  "Participants ({{ numberOfParticipants }})": "Participants ({{ numberOfParticipants }})",
  "{{ userName }} is sharing their screen": "{{ userName }} is sharing their screen",
  "{{ userName }} is requesting to speak": "{{ userName }} is requesting to speak",
  "{{ userName }} is requesting to share their camera": "{{ userName }} is requesting to share their camera",
  "{{ userName }} is requesting to present their screen": "{{ userName }} is requesting to present their screen",
  "{{ userName }} is requesting permission: {{ permission }}": "{{ userName }} is requesting permission: {{ permission }}"
};
var translations = { en };
var StreamVideo = (props) => {
  return (0, import_jsx_runtime.jsx)(StreamVideoProvider, { translationsOverrides: translations, ...props });
};
StreamVideo.displayName = "StreamVideo";
function applyFilter(obj, filter) {
  if ("$and" in filter) {
    return filter.$and.every((f) => applyFilter(obj, f));
  }
  if ("$or" in filter) {
    return filter.$or.some((f) => applyFilter(obj, f));
  }
  if ("$not" in filter) {
    return !applyFilter(obj, filter.$not);
  }
  return checkConditions(obj, filter);
}
var isDateString = (value) => typeof value === "string" && /^((?:(\d{4}-\d{2}-\d{2})T(\d{2}:\d{2}:\d{2}(?:\.\d+)?))(Z|[+-]\d{2}:\d{2})?)$/.test(value);
function checkConditions(obj, conditions) {
  let match = true;
  for (const key of Object.keys(conditions)) {
    const operator = conditions[key];
    const maybeOperator = operator && typeof operator === "object";
    let value = obj[key];
    if (value instanceof Date) {
      value = value.getTime();
    } else if (isDateString(value)) {
      value = new Date(value).getTime();
    }
    if (maybeOperator && "$eq" in operator) {
      const eqOperator = operator;
      const eqOperatorValue = isDateString(eqOperator.$eq) ? new Date(eqOperator.$eq).getTime() : eqOperator.$eq;
      match && (match = eqOperatorValue === value);
    } else if (maybeOperator && "$neq" in operator) {
      const neqOperator = operator;
      match && (match = neqOperator.$neq !== value);
    } else if (maybeOperator && "$in" in operator) {
      const inOperator = operator;
      match && (match = inOperator.$in.includes(value));
    } else if (maybeOperator && "$contains" in operator) {
      if (Array.isArray(value)) {
        const containsOperator = operator;
        match && (match = value.includes(containsOperator.$contains));
      } else {
        match = false;
      }
    } else if (maybeOperator && "$gt" in operator) {
      const gtOperator = operator;
      const gtOperatorValue = isDateString(gtOperator.$gt) ? new Date(gtOperator.$gt).getTime() : gtOperator.$gt;
      match && (match = value > gtOperatorValue);
    } else if (maybeOperator && "$gte" in operator) {
      const gteOperator = operator;
      const gteOperatorValue = isDateString(gteOperator.$gte) ? new Date(gteOperator.$gte).getTime() : gteOperator.$gte;
      match && (match = value >= gteOperatorValue);
    } else if (maybeOperator && "$lt" in operator) {
      const ltOperator = operator;
      const ltOperatorValue = isDateString(ltOperator.$lt) ? new Date(ltOperator.$lt).getTime() : ltOperator.$lt;
      match && (match = value < ltOperatorValue);
    } else if (maybeOperator && "$lte" in operator) {
      const lteOperator = operator;
      const lteOperatorValue = isDateString(lteOperator.$lte) ? new Date(lteOperator.$lte).getTime() : lteOperator.$lte;
      match && (match = value <= lteOperatorValue);
    } else {
      const eqValue = operator;
      match && (match = eqValue === value);
    }
    if (!match) {
      return false;
    }
  }
  return true;
}
var useFilteredParticipants = ({ excludeLocalParticipant = false, filterParticipants }) => {
  const { useParticipants, useRemoteParticipants } = useCallStateHooks();
  const allParticipants = useParticipants();
  const remoteParticipants = useRemoteParticipants();
  return (0, import_react.useMemo)(() => {
    const unfilteredParticipants = excludeLocalParticipant ? remoteParticipants : allParticipants;
    return filterParticipants ? applyParticipantsFilter(unfilteredParticipants, filterParticipants) : unfilteredParticipants;
  }, [
    allParticipants,
    remoteParticipants,
    excludeLocalParticipant,
    filterParticipants
  ]);
};
var applyParticipantsFilter = (participants, filter) => {
  const filterCallback = typeof filter === "function" ? filter : (participant) => applyFilter({
    userId: participant.userId,
    isSpeaking: participant.isSpeaking,
    isDominantSpeaker: participant.isDominantSpeaker,
    name: participant.name,
    roles: participant.roles,
    isPinned: isPinned(participant),
    hasVideo: hasVideo(participant),
    hasAudio: hasAudio(participant),
    hasScreenShare: hasScreenShare(participant)
  }, filter);
  return participants.filter(filterCallback);
};
var usePaginatedLayoutSortPreset = (call) => {
  (0, import_react.useEffect)(() => {
    if (!call)
      return;
    call.setSortParticipantsBy(paginatedLayoutSortPreset);
    return () => {
      resetSortPreset(call);
    };
  }, [call]);
};
var useSpeakerLayoutSortPreset = (call, isOneOnOneCall) => {
  (0, import_react.useEffect)(() => {
    if (!call)
      return;
    if (isOneOnOneCall) {
      call.setSortParticipantsBy(combineComparators(screenSharing, loggedIn));
    } else {
      call.setSortParticipantsBy(speakerLayoutSortPreset);
    }
    return () => {
      resetSortPreset(call);
    };
  }, [call, isOneOnOneCall]);
};
var useRawRemoteParticipants = () => {
  const { useRawParticipants } = useCallStateHooks();
  const rawParticipants = useRawParticipants();
  return (0, import_react.useMemo)(() => rawParticipants.filter((p) => !p.isLocalParticipant), [rawParticipants]);
};
var resetSortPreset = (call) => {
  const callConfig = CallTypes.get(call.type);
  call.setSortParticipantsBy(callConfig.options.sortParticipantsBy || defaultSortPreset);
};
var loggedIn = (a, b) => {
  if (a.isLocalParticipant)
    return 1;
  if (b.isLocalParticipant)
    return -1;
  return 0;
};
var LivestreamLayout = (props) => {
  const { useParticipants, useHasOngoingScreenShare } = useCallStateHooks();
  const call = useCall();
  const participants = useParticipants();
  const [currentSpeaker] = participants;
  const remoteParticipants = useRawRemoteParticipants();
  const hasOngoingScreenShare = useHasOngoingScreenShare();
  const presenter = hasOngoingScreenShare ? participants.find(hasScreenShare) : void 0;
  usePaginatedLayoutSortPreset(call);
  const { floatingParticipantProps, muted, ParticipantViewUI } = props;
  const overlay = ParticipantViewUI ?? (0, import_jsx_runtime.jsx)(ParticipantOverlay, { showParticipantCount: props.showParticipantCount, showDuration: props.showDuration, showLiveBadge: props.showLiveBadge, showMuteButton: props.showMuteButton, showSpeakerName: props.showSpeakerName, enableFullScreen: props.enableFullScreen });
  const floatingParticipantOverlay = hasOngoingScreenShare && (ParticipantViewUI ?? (0, import_jsx_runtime.jsx)(
    ParticipantOverlay,
    {
      // these elements aren't needed for the video feed
      showParticipantCount: floatingParticipantProps?.showParticipantCount ?? false,
      showDuration: floatingParticipantProps?.showDuration ?? false,
      showLiveBadge: floatingParticipantProps?.showLiveBadge ?? false,
      showSpeakerName: floatingParticipantProps?.showSpeakerName ?? true,
      enableFullScreen: floatingParticipantProps?.enableFullScreen ?? true
    }
  ));
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__livestream-layout__wrapper", children: [!muted && (0, import_jsx_runtime.jsx)(ParticipantsAudio, { participants: remoteParticipants }), hasOngoingScreenShare && presenter && (0, import_jsx_runtime.jsx)(ParticipantView, { className: "str-video__livestream-layout__screen-share", participant: presenter, ParticipantViewUI: overlay, trackType: "screenShareTrack", muteAudio: true }), currentSpeaker && (0, import_jsx_runtime.jsx)(ParticipantView, { className: clsx_default(hasOngoingScreenShare && clsx_default("str-video__livestream-layout__floating-participant", `str-video__livestream-layout__floating-participant--${floatingParticipantProps?.position ?? "top-right"}`)), participant: currentSpeaker, ParticipantViewUI: floatingParticipantOverlay || overlay, mirror: props.mirrorLocalParticipantVideo !== false ? void 0 : false, muteAudio: true })] });
};
LivestreamLayout.displayName = "LivestreamLayout";
var BackstageLayout = (props) => {
  const { showEarlyParticipantCount = true, humanizeParticipantCount = true } = props;
  const { useParticipantCount, useCallStartsAt } = useCallStateHooks();
  const participantCount = useParticipantCount();
  const startsAt = useCallStartsAt();
  const { t } = useI18n();
  return (0, import_jsx_runtime.jsx)("div", { className: "str-video__livestream-layout__wrapper", children: (0, import_jsx_runtime.jsxs)("div", { className: "str-video__livestream-layout__backstage", children: [startsAt && (0, import_jsx_runtime.jsx)("span", { className: "str-video__livestream-layout__starts-at", children: startsAt.getTime() < Date.now() ? t("Livestream starts soon") : t("Livestream starts at {{ startsAt }}", { startsAt }) }), showEarlyParticipantCount && (0, import_jsx_runtime.jsx)("span", { className: "str-video__livestream-layout__early-viewers-count", children: t("{{ count }} participants joined early", {
    count: humanizeParticipantCount ? humanize(participantCount) : participantCount
  }) })] }) });
};
BackstageLayout.displayName = "BackstageLayout";
var ParticipantOverlay = (props) => {
  const { enableFullScreen = true, showParticipantCount = true, humanizeParticipantCount = true, showDuration = true, showLiveBadge = true, showMuteButton = true, showSpeakerName = false } = props;
  const overlayBarVisible = enableFullScreen || showParticipantCount || showDuration || showLiveBadge || showMuteButton || showSpeakerName;
  const { participant } = useParticipantViewContext();
  const { useParticipantCount, useSpeakerState } = useCallStateHooks();
  const participantCount = useParticipantCount();
  const duration = useUpdateCallDuration();
  const toggleFullScreen = useToggleFullScreen();
  const { speaker, volume } = useSpeakerState();
  const isSpeakerMuted = volume === 0;
  const { t } = useI18n();
  return (0, import_jsx_runtime.jsx)("div", { className: "str-video__livestream-layout__overlay", children: overlayBarVisible && (0, import_jsx_runtime.jsxs)("div", { className: "str-video__livestream-layout__overlay__bar", children: [showLiveBadge && (0, import_jsx_runtime.jsx)("span", { className: "str-video__livestream-layout__live-badge", children: t("Live") }), showParticipantCount && (0, import_jsx_runtime.jsx)("span", { className: "str-video__livestream-layout__viewers-count", children: humanizeParticipantCount ? humanize(participantCount) : participantCount }), showSpeakerName && (0, import_jsx_runtime.jsx)("span", { className: "str-video__livestream-layout__speaker-name", title: participant.name || participant.userId || "", children: participant.name || participant.userId || "" }), showDuration && (0, import_jsx_runtime.jsx)("span", { className: "str-video__livestream-layout__duration", children: formatDuration(duration) }), showMuteButton && (0, import_jsx_runtime.jsx)("span", { className: clsx_default("str-video__livestream-layout__mute-button", isSpeakerMuted && "str-video__livestream-layout__mute-button--muted"), onClick: () => speaker.setVolume(isSpeakerMuted ? 1 : 0) }), enableFullScreen && (0, import_jsx_runtime.jsx)("span", { className: "str-video__livestream-layout__go-fullscreen", onClick: toggleFullScreen })] }) });
};
var useUpdateCallDuration = () => {
  const { useIsCallLive, useCallSession } = useCallStateHooks();
  const isCallLive = useIsCallLive();
  const session = useCallSession();
  const [duration, setDuration] = (0, import_react.useState)(() => {
    if (!session || !session.live_started_at)
      return 0;
    const liveStartTime = new Date(session.live_started_at);
    const now = /* @__PURE__ */ new Date();
    return Math.floor((now.getTime() - liveStartTime.getTime()) / 1e3);
  });
  (0, import_react.useEffect)(() => {
    if (!isCallLive)
      return;
    const interval = setInterval(() => {
      setDuration((d) => d + 1);
    }, 1e3);
    return () => {
      clearInterval(interval);
    };
  }, [isCallLive]);
  return duration;
};
var useToggleFullScreen = () => {
  const { participantViewElement } = useParticipantViewContext();
  const [isFullscreen, setIsFullscreen] = (0, import_react.useState)(!!document.fullscreenElement);
  (0, import_react.useEffect)(() => {
    const handler = () => setIsFullscreen(!!document.fullscreenElement);
    document.addEventListener("fullscreenchange", handler);
    return () => {
      document.removeEventListener("fullscreenchange", handler);
    };
  }, []);
  return (0, import_react.useCallback)(() => {
    if (isFullscreen) {
      document.exitFullscreen().catch((err) => {
        console.error("Failed to exit fullscreen", err);
      });
    } else {
      participantViewElement?.requestFullscreen().catch((err) => {
        console.error("Failed to enter fullscreen", err);
      });
    }
  }, [isFullscreen, participantViewElement]);
};
var formatDuration = (durationInMs) => {
  const days = Math.floor(durationInMs / 86400);
  const hours = Math.floor(durationInMs / 3600);
  const minutes = Math.floor(durationInMs % 3600 / 60);
  const seconds = durationInMs % 60;
  return `${days ? days + " " : ""}${hours ? hours + ":" : ""}${minutes < 10 ? "0" : ""}${minutes}:${seconds < 10 ? "0" : ""}${seconds}`;
};
var GROUP_SIZE = 16;
var PaginatedGridLayoutGroup = ({ group, mirror, VideoPlaceholder, PictureInPicturePlaceholder, ParticipantViewUI }) => {
  return (0, import_jsx_runtime.jsx)("div", { className: clsx_default("str-video__paginated-grid-layout__group", {
    "str-video__paginated-grid-layout--one": group.length === 1,
    "str-video__paginated-grid-layout--two-four": group.length >= 2 && group.length <= 4,
    "str-video__paginated-grid-layout--five-nine": group.length >= 5 && group.length <= 9
  }), children: group.map((participant) => (0, import_jsx_runtime.jsx)(ParticipantView, { participant, muteAudio: true, mirror, VideoPlaceholder, PictureInPicturePlaceholder, ParticipantViewUI }, participant.sessionId)) });
};
var PaginatedGridLayout = (props) => {
  const { groupSize = (props.groupSize || 0) > 0 ? props.groupSize || GROUP_SIZE : GROUP_SIZE, excludeLocalParticipant = false, filterParticipants, mirrorLocalParticipantVideo = true, pageArrowsVisible = true, VideoPlaceholder, ParticipantViewUI = DefaultParticipantViewUI, PictureInPicturePlaceholder, muted } = props;
  const [page, setPage] = (0, import_react.useState)(0);
  const [paginatedGridLayoutWrapperElement, setPaginatedGridLayoutWrapperElement] = (0, import_react.useState)(null);
  const call = useCall();
  const remoteParticipants = useRawRemoteParticipants();
  const participants = useFilteredParticipants({
    excludeLocalParticipant,
    filterParticipants
  });
  usePaginatedLayoutSortPreset(call);
  (0, import_react.useEffect)(() => {
    if (!paginatedGridLayoutWrapperElement || !call)
      return;
    const cleanup = call.setViewport(paginatedGridLayoutWrapperElement);
    return () => cleanup();
  }, [paginatedGridLayoutWrapperElement, call]);
  const participantGroups = (0, import_react.useMemo)(() => chunk(participants, groupSize), [participants, groupSize]);
  const pageCount = participantGroups.length;
  (0, import_react.useEffect)(() => {
    if (page > pageCount - 1) {
      setPage(Math.max(0, pageCount - 1));
    }
  }, [page, pageCount]);
  const selectedGroup = participantGroups[page];
  const mirror = mirrorLocalParticipantVideo ? void 0 : false;
  if (!call)
    return null;
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__paginated-grid-layout__wrapper", ref: setPaginatedGridLayoutWrapperElement, children: [!muted && (0, import_jsx_runtime.jsx)(ParticipantsAudio, { participants: remoteParticipants }), (0, import_jsx_runtime.jsxs)("div", { className: "str-video__paginated-grid-layout", children: [pageArrowsVisible && pageCount > 1 && (0, import_jsx_runtime.jsx)(IconButton, { icon: "caret-left", disabled: page === 0, onClick: () => setPage((currentPage) => Math.max(0, currentPage - 1)) }), selectedGroup && (0, import_jsx_runtime.jsx)(PaginatedGridLayoutGroup, { group: selectedGroup, mirror, VideoPlaceholder, ParticipantViewUI, PictureInPicturePlaceholder }), pageArrowsVisible && pageCount > 1 && (0, import_jsx_runtime.jsx)(IconButton, { disabled: page === pageCount - 1, icon: "caret-right", onClick: () => setPage((currentPage) => Math.min(pageCount - 1, currentPage + 1)) })] })] });
};
PaginatedGridLayout.displayName = "PaginatedGridLayout";
var useCalculateHardLimit = (wrapperElement, hostElement, limit) => {
  const [calculatedLimit, setCalculatedLimit] = (0, import_react.useState)({
    vertical: typeof limit === "number" ? limit : null,
    horizontal: typeof limit === "number" ? limit : null
  });
  (0, import_react.useEffect)(() => {
    if (!hostElement || !wrapperElement || typeof limit === "number" || typeof limit === "undefined")
      return;
    let childWidth = null;
    let childHeight = null;
    const resizeObserver = new ResizeObserver((entries, observer) => {
      if (entries.length > 1) {
        const child = hostElement.firstChild;
        if (child) {
          childHeight = child.clientHeight;
          childWidth = child.clientWidth;
          observer.unobserve(hostElement);
        }
      }
      if (childHeight === null || childWidth === null)
        return;
      const vertical = Math.floor(wrapperElement.clientHeight / childHeight);
      const horizontal = Math.floor(wrapperElement.clientWidth / childWidth);
      setCalculatedLimit((pv) => {
        if (pv.vertical !== vertical || pv.horizontal !== horizontal)
          return { vertical, horizontal };
        return pv;
      });
    });
    resizeObserver.observe(wrapperElement);
    resizeObserver.observe(hostElement);
    return () => {
      resizeObserver.disconnect();
    };
  }, [hostElement, limit, wrapperElement]);
  return calculatedLimit;
};
var DefaultParticipantViewUIBar = () => (0, import_jsx_runtime.jsx)(DefaultParticipantViewUI, { menuPlacement: "top-end" });
var SpeakerLayout = ({ ParticipantViewUIBar = DefaultParticipantViewUIBar, ParticipantViewUISpotlight = DefaultParticipantViewUI, VideoPlaceholder, PictureInPicturePlaceholder, participantsBarPosition = "bottom", participantsBarLimit, mirrorLocalParticipantVideo = true, excludeLocalParticipant = false, filterParticipants, pageArrowsVisible = true, muted, enableDragToScroll = false }) => {
  const call = useCall();
  const { useParticipants } = useCallStateHooks();
  const allParticipants = useParticipants();
  const remoteParticipants = useRawRemoteParticipants();
  const [participantInSpotlight, ...otherParticipants] = useFilteredParticipants({ excludeLocalParticipant, filterParticipants });
  const [participantsBarWrapperElement, setParticipantsBarWrapperElement] = (0, import_react.useState)(null);
  const [participantsBarElement, setParticipantsBarElement] = (0, import_react.useState)(null);
  const [buttonsWrapperElement, setButtonsWrapperElement] = (0, import_react.useState)(null);
  const isSpeakerScreenSharing = participantInSpotlight && hasScreenShare(participantInSpotlight);
  const hardLimit = useCalculateHardLimit(buttonsWrapperElement, participantsBarElement, participantsBarLimit);
  const isVertical = participantsBarPosition === "left" || participantsBarPosition === "right";
  const isHorizontal = participantsBarPosition === "top" || participantsBarPosition === "bottom";
  (0, import_react.useEffect)(() => {
    if (!participantsBarWrapperElement || !call)
      return;
    const cleanup = call.setViewport(participantsBarWrapperElement);
    return () => cleanup();
  }, [participantsBarWrapperElement, call]);
  const isOneOnOneCall = allParticipants.length === 2;
  useSpeakerLayoutSortPreset(call, isOneOnOneCall);
  useDragToScroll(participantsBarWrapperElement, {
    enabled: enableDragToScroll
  });
  let participantsWithAppliedLimit = otherParticipants;
  const hardLimitToApply = isVertical ? hardLimit.vertical : hardLimit.horizontal;
  if (typeof participantsBarLimit !== "undefined" && hardLimitToApply !== null) {
    participantsWithAppliedLimit = otherParticipants.slice(
      0,
      // subtract 1 if speaker is sharing screen as
      // that one is rendered independently from otherParticipants array
      hardLimitToApply - (isSpeakerScreenSharing ? 1 : 0)
    );
  }
  const mirror = mirrorLocalParticipantVideo ? void 0 : false;
  if (!call)
    return null;
  const renderParticipantsBar = participantsBarPosition && (participantsWithAppliedLimit.length > 0 || isSpeakerScreenSharing);
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__speaker-layout__wrapper", children: [!muted && (0, import_jsx_runtime.jsx)(ParticipantsAudio, { participants: remoteParticipants }), (0, import_jsx_runtime.jsxs)("div", { className: clsx_default("str-video__speaker-layout", participantsBarPosition && `str-video__speaker-layout--variant-${participantsBarPosition}`), children: [(0, import_jsx_runtime.jsx)("div", { className: "str-video__speaker-layout__spotlight", children: participantInSpotlight && (0, import_jsx_runtime.jsx)(ParticipantView, { participant: participantInSpotlight, muteAudio: true, mirror, trackType: isSpeakerScreenSharing ? "screenShareTrack" : "videoTrack", ParticipantViewUI: ParticipantViewUISpotlight, VideoPlaceholder, PictureInPicturePlaceholder }) }), renderParticipantsBar && (0, import_jsx_runtime.jsxs)("div", { ref: setButtonsWrapperElement, className: "str-video__speaker-layout__participants-bar-buttons-wrapper", children: [(0, import_jsx_runtime.jsx)("div", { className: "str-video__speaker-layout__participants-bar-wrapper", ref: setParticipantsBarWrapperElement, children: (0, import_jsx_runtime.jsxs)("div", { ref: setParticipantsBarElement, className: "str-video__speaker-layout__participants-bar", children: [isSpeakerScreenSharing && (0, import_jsx_runtime.jsx)("div", { className: "str-video__speaker-layout__participant-tile", children: (0, import_jsx_runtime.jsx)(ParticipantView, { participant: participantInSpotlight, ParticipantViewUI: ParticipantViewUIBar, VideoPlaceholder, PictureInPicturePlaceholder, mirror, muteAudio: true }) }, participantInSpotlight.sessionId), participantsWithAppliedLimit.map((participant) => (0, import_jsx_runtime.jsx)("div", { className: "str-video__speaker-layout__participant-tile", children: (0, import_jsx_runtime.jsx)(ParticipantView, { participant, ParticipantViewUI: ParticipantViewUIBar, VideoPlaceholder, PictureInPicturePlaceholder, mirror, muteAudio: true }) }, participant.sessionId))] }) }), pageArrowsVisible && isVertical && (0, import_jsx_runtime.jsx)(VerticalScrollButtons, { scrollWrapper: participantsBarWrapperElement }), pageArrowsVisible && isHorizontal && (0, import_jsx_runtime.jsx)(HorizontalScrollButtons, { scrollWrapper: participantsBarWrapperElement })] })] })] });
};
SpeakerLayout.displayName = "SpeakerLayout";
var HorizontalScrollButtons = ({ scrollWrapper }) => {
  const scrollPosition = useHorizontalScrollPosition(scrollWrapper);
  const scrollStartClickHandler = () => {
    scrollWrapper?.scrollBy({ left: -150, behavior: "smooth" });
  };
  const scrollEndClickHandler = () => {
    scrollWrapper?.scrollBy({ left: 150, behavior: "smooth" });
  };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [scrollPosition && scrollPosition !== "start" && (0, import_jsx_runtime.jsx)(IconButton, { onClick: scrollStartClickHandler, icon: "caret-left", className: "str-video__speaker-layout__participants-bar--button-left" }), scrollPosition && scrollPosition !== "end" && (0, import_jsx_runtime.jsx)(IconButton, { onClick: scrollEndClickHandler, icon: "caret-right", className: "str-video__speaker-layout__participants-bar--button-right" })] });
};
var VerticalScrollButtons = ({ scrollWrapper }) => {
  const scrollPosition = useVerticalScrollPosition(scrollWrapper);
  const scrollTopClickHandler = () => {
    scrollWrapper?.scrollBy({ top: -150, behavior: "smooth" });
  };
  const scrollBottomClickHandler = () => {
    scrollWrapper?.scrollBy({ top: 150, behavior: "smooth" });
  };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [scrollPosition && scrollPosition !== "top" && (0, import_jsx_runtime.jsx)(IconButton, { onClick: scrollTopClickHandler, icon: "caret-up", className: "str-video__speaker-layout__participants-bar--button-top" }), scrollPosition && scrollPosition !== "bottom" && (0, import_jsx_runtime.jsx)(IconButton, { onClick: scrollBottomClickHandler, icon: "caret-down", className: "str-video__speaker-layout__participants-bar--button-bottom" })] });
};
var Pip = (props) => {
  const { t } = useI18n();
  const { excludeLocalParticipant = false, filterParticipants, mirrorLocalParticipantVideo = true, VideoPlaceholder, ParticipantViewUI = DefaultParticipantViewUI } = props;
  const [layoutWrapperElement, setLayoutWrapperElement] = (0, import_react.useState)(null);
  const call = useCall();
  const participants = useFilteredParticipants({
    excludeLocalParticipant,
    filterParticipants
  });
  const screenSharingParticipant = participants.find((p) => hasScreenShare(p));
  usePaginatedLayoutSortPreset(call);
  (0, import_react.useEffect)(() => {
    if (!layoutWrapperElement || !call)
      return;
    return call.setViewport(layoutWrapperElement);
  }, [layoutWrapperElement, call]);
  const mirror = mirrorLocalParticipantVideo ? void 0 : false;
  if (!call)
    return null;
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__pip-layout", ref: setLayoutWrapperElement, children: [screenSharingParticipant && (screenSharingParticipant.isLocalParticipant ? (0, import_jsx_runtime.jsxs)("div", { className: "str-video__pip-screen-share-local", children: [(0, import_jsx_runtime.jsx)(Icon, { icon: "screen-share-off" }), (0, import_jsx_runtime.jsx)("span", { className: "str-video__pip-screen-share-local__title", children: t("You are presenting your screen") })] }) : (0, import_jsx_runtime.jsx)(ParticipantView, { participant: screenSharingParticipant, trackType: "screenShareTrack", muteAudio: true, mirror: false, VideoPlaceholder, ParticipantViewUI })), participants.map((participant) => (0, import_jsx_runtime.jsx)(ParticipantView, { participant, muteAudio: true, mirror, VideoPlaceholder, ParticipantViewUI }, participant.sessionId))] });
};
Pip.displayName = "PipLayout.Pip";
var Host = () => {
  const remoteParticipants = useRawRemoteParticipants();
  return (0, import_jsx_runtime.jsx)(ParticipantsAudio, { participants: remoteParticipants });
};
Host.displayName = "PipLayout.Host";
var getGridDensity = (count) => {
  if (count === 1)
    return "single";
  if (count <= 5)
    return "small";
  if (count <= 9)
    return "medium";
  if (count <= 16)
    return "large";
  return "overflow";
};
var Grid = (props) => {
  const { t } = useI18n();
  const { excludeLocalParticipant = false, filterParticipants, mirrorLocalParticipantVideo = true, groupSize = 9, pageArrowsVisible = true, VideoPlaceholder, ParticipantViewUI = DefaultParticipantViewUI } = props;
  const [page, setPage] = (0, import_react.useState)(0);
  const [wrapperElement, setWrapperElement] = (0, import_react.useState)(null);
  const call = useCall();
  const participants = useFilteredParticipants({
    excludeLocalParticipant,
    filterParticipants
  });
  const screenSharingParticipant = participants.find((p) => hasScreenShare(p));
  usePaginatedLayoutSortPreset(call);
  (0, import_react.useEffect)(() => {
    if (!wrapperElement || !call)
      return;
    return call.setViewport(wrapperElement);
  }, [wrapperElement, call]);
  const participantGroups = (0, import_react.useMemo)(() => chunk(participants, groupSize), [participants, groupSize]);
  const pageCount = participantGroups.length;
  if (page > pageCount - 1) {
    setPage(Math.max(0, pageCount - 1));
  }
  const selectedGroup = participantGroups[page];
  const mirror = mirrorLocalParticipantVideo ? void 0 : false;
  if (!call)
    return null;
  return (0, import_jsx_runtime.jsxs)("div", { className: "str-video__pip-layout str-video__pip-layout--grid", ref: setWrapperElement, children: [screenSharingParticipant && (screenSharingParticipant.isLocalParticipant ? (0, import_jsx_runtime.jsxs)("div", { className: "str-video__pip-screen-share-local", children: [(0, import_jsx_runtime.jsx)(Icon, { icon: "screen-share-off" }), (0, import_jsx_runtime.jsx)("span", { className: "str-video__pip-screen-share-local__title", children: t("You are presenting your screen") })] }) : (0, import_jsx_runtime.jsx)(ParticipantView, { participant: screenSharingParticipant, trackType: "screenShareTrack", muteAudio: true, mirror: false, VideoPlaceholder, ParticipantViewUI })), (0, import_jsx_runtime.jsxs)("div", { className: "str-video__pip-layout__grid-container", children: [pageArrowsVisible && page > 0 && (0, import_jsx_runtime.jsx)(IconButton, { icon: "caret-left", onClick: () => setPage((currentPage) => Math.max(0, currentPage - 1)), className: "str-video__pip-layout__pagination-button str-video__pip-layout__pagination-button--left" }), selectedGroup && (0, import_jsx_runtime.jsx)("div", { className: clsx_default("str-video__pip-layout__grid", `str-video__pip-layout__grid--${getGridDensity(selectedGroup.length)}`), children: selectedGroup.map((participant) => (0, import_jsx_runtime.jsx)(ParticipantView, { participant, muteAudio: true, mirror, VideoPlaceholder, ParticipantViewUI }, participant.sessionId)) }), pageArrowsVisible && page < pageCount - 1 && (0, import_jsx_runtime.jsx)(IconButton, { icon: "caret-right", onClick: () => setPage((currentPage) => Math.min(pageCount - 1, currentPage + 1)), className: "str-video__pip-layout__pagination-button str-video__pip-layout__pagination-button--right" })] })] });
};
Grid.displayName = "PipLayout.Grid";
var PipLayout = { Pip, Host, Grid };
var LivestreamPlayer = (props) => {
  const { callType, callId, children, ...restProps } = props;
  const client = useStreamVideoClient();
  const [call, setCall] = (0, import_react.useState)();
  const onError = useEffectEvent(props.onError ?? (() => {
  }));
  (0, import_react.useEffect)(() => {
    if (!client)
      return;
    const myCall = client.call(callType, callId);
    setCall(myCall);
    myCall.get().catch((e) => {
      console.error("Failed to fetch call", e);
      onError(e);
    });
    return () => {
      myCall.leave().catch((e) => {
        console.error("Failed to leave call", e);
      });
      setCall(void 0);
    };
  }, [callId, callType, client]);
  if (!call) {
    return null;
  }
  return (0, import_jsx_runtime.jsxs)(StreamCall, { call, children: [(0, import_jsx_runtime.jsx)(LivestreamCall, { ...restProps }), children] });
};
var LivestreamCall = (props) => {
  const call = useLivestreamCall(props);
  const { useIsCallLive } = useCallStateHooks();
  const isLive = useIsCallLive();
  if (!call)
    return null;
  if (isLive) {
    return (0, import_jsx_runtime.jsx)(LivestreamLayout, { ...props.layoutProps });
  }
  return (0, import_jsx_runtime.jsx)(BackstageLayout, { ...props.backstageProps });
};
var useLivestreamCall = (props) => {
  const call = useCall();
  const { useIsCallLive, useOwnCapabilities } = useCallStateHooks();
  const canJoinLive = useIsCallLive();
  const canJoinEarly = useCanJoinEarly();
  const canJoinBackstage = useOwnCapabilities()?.includes("join-backstage") ?? false;
  const canJoinAsap = canJoinLive || canJoinEarly || canJoinBackstage;
  const joinBehavior = props.joinBehavior ?? "asap";
  const canJoin = joinBehavior === "asap" && canJoinAsap || joinBehavior === "live" && canJoinLive;
  const onError = useEffectEvent(props.onError ?? (() => {
  }));
  (0, import_react.useEffect)(() => {
    if (call && call.state.callingState === CallingState.IDLE && canJoin) {
      call.join().catch((e) => {
        console.error("Failed to join call", e);
        onError(e);
      });
    }
  }, [call, canJoin]);
  return call;
};
var useCanJoinEarly = () => {
  const { useCallStartsAt, useCallSettings } = useCallStateHooks();
  const startsAt = useCallStartsAt();
  const settings = useCallSettings();
  const joinAheadTimeSeconds = settings?.backstage.join_ahead_time_seconds;
  const [canJoinEarly, setCanJoinEarly] = (0, import_react.useState)(() => checkCanJoinEarly(startsAt, joinAheadTimeSeconds));
  (0, import_react.useEffect)(() => {
    if (!canJoinEarly) {
      const handle = setInterval(() => {
        setCanJoinEarly(checkCanJoinEarly(startsAt, joinAheadTimeSeconds));
      }, 1e3);
      return () => clearInterval(handle);
    }
  }, [canJoinEarly, startsAt, joinAheadTimeSeconds]);
  return canJoinEarly;
};
var checkCanJoinEarly = (startsAt, joinAheadTimeSeconds) => {
  if (!startsAt) {
    return false;
  }
  return Date.now() >= +startsAt - (joinAheadTimeSeconds ?? 0) * 1e3;
};
var [major, minor, patch] = "1.31.6".split(".");
setSdkInfo({
  type: models.SdkType.REACT,
  major,
  minor,
  patch
});
export {
  AcceptCallButton,
  Audio,
  AudioSettingsRequestDefaultDeviceEnum,
  AudioSettingsResponseDefaultDeviceEnum,
  AudioVolumeIndicator,
  Avatar,
  AvatarFallback,
  AxiosError,
  BackgroundFiltersProvider,
  BackstageLayout,
  BaseVideo,
  browsers as Browsers,
  Call,
  CallControls,
  CallParticipantListing,
  CallParticipantListingItem,
  CallParticipantsList,
  CallPreview,
  CallRecordingFailedEventRecordingTypeEnum,
  CallRecordingList,
  CallRecordingListHeader,
  CallRecordingListItem,
  CallRecordingReadyEventRecordingTypeEnum,
  CallRecordingStartedEventRecordingTypeEnum,
  CallRecordingStoppedEventRecordingTypeEnum,
  CallState,
  CallStats,
  CallStatsButton,
  CallType,
  CallTypes,
  CallingState,
  CameraManager,
  CameraManagerState,
  CancelCallButton,
  CancelCallConfirmButton,
  CompositeButton,
  CreateDeviceRequestPushProviderEnum,
  DebounceType,
  DefaultParticipantViewUI,
  DefaultReactionsMenu,
  DefaultScreenShareOverlay,
  DefaultVideoPlaceholder2 as DefaultVideoPlaceholder,
  DeviceManager,
  DeviceManagerState,
  DeviceSelector,
  DeviceSelectorAudioInput,
  DeviceSelectorAudioOutput,
  DeviceSelectorVideo,
  DeviceSettings,
  DropDownSelect,
  DropDownSelectOption,
  DynascaleManager,
  EmptyCallRecordingListing,
  ErrorFromResponse,
  FrameRecordingSettingsRequestModeEnum,
  FrameRecordingSettingsRequestQualityEnum,
  FrameRecordingSettingsResponseModeEnum,
  GenericMenu,
  GenericMenuButtonItem,
  Icon,
  IconButton,
  IndividualRecordingSettingsRequestModeEnum,
  IndividualRecordingSettingsResponseModeEnum,
  IngressAudioEncodingOptionsRequestChannelsEnum,
  IngressSourceRequestFpsEnum,
  IngressVideoLayerRequestCodecEnum,
  LayoutSettingsRequestNameEnum,
  LivestreamLayout,
  LivestreamPlayer,
  LoadingCallRecordingListing,
  LoadingIndicator,
  LogLevelEnum,
  MenuToggle,
  MenuVisualType,
  MicrophoneManager,
  MicrophoneManagerState,
  NoiseCancellationProvider,
  NoiseCancellationSettingsModeEnum,
  Notification,
  OwnCapability,
  PaginatedGridLayout,
  ParticipantActionsContextMenu,
  ParticipantDetails,
  ParticipantView,
  ParticipantViewContext,
  ParticipantsAudio,
  PermissionNotification,
  PermissionRequestList,
  PermissionRequests,
  PipLayout,
  RNSpeechDetector,
  RTMPBroadcastRequestQualityEnum,
  RTMPSettingsRequestQualityEnum,
  RawRecordingSettingsRequestModeEnum,
  RawRecordingSettingsResponseModeEnum,
  Reaction,
  ReactionsButton,
  RecordCallButton,
  RecordCallConfirmationButton,
  RecordSettingsRequestModeEnum,
  RecordSettingsRequestQualityEnum,
  RecordingInProgressNotification,
  Restricted,
  RingingCall,
  RingingCallControls,
  rxUtils as RxUtils,
  ScreenShareButton,
  ScreenShareManager,
  ScreenShareState,
  SearchInput,
  SearchResults,
  events as SfuEvents,
  SfuJoinError,
  models as SfuModels,
  SpeakerLayout,
  SpeakerManager,
  SpeakerState,
  SpeakerTest,
  SpeakingWhileMutedNotification,
  SpeechIndicator,
  StartClosedCaptionsRequestLanguageEnum,
  StartTranscriptionRequestLanguageEnum,
  StatCard,
  StreamCall,
  StreamCallProvider,
  StreamI18n,
  StreamI18nProvider,
  StreamSfuClient,
  StreamTheme,
  StreamVideo,
  StreamVideoClient,
  StreamVideoProvider,
  StreamVideoReadOnlyStateStore,
  StreamVideoWriteableStateStore,
  TextButton,
  ToggleAudioOutputButton,
  ToggleAudioPreviewButton,
  ToggleAudioPublishingButton,
  ToggleVideoPreviewButton,
  ToggleVideoPublishingButton,
  Tooltip,
  TranscriptionSettingsRequestClosedCaptionModeEnum,
  TranscriptionSettingsRequestLanguageEnum,
  TranscriptionSettingsRequestModeEnum,
  TranscriptionSettingsResponseClosedCaptionModeEnum,
  TranscriptionSettingsResponseLanguageEnum,
  TranscriptionSettingsResponseModeEnum,
  Video$1 as Video,
  VideoPreview,
  VideoSettingsRequestCameraFacingEnum,
  VideoSettingsResponseCameraFacingEnum,
  ViewportTracker,
  VisibilityState,
  WithTooltip,
  applyFilter,
  checkIfAudioOutputChangeSupported,
  combineComparators,
  conditional,
  createSoundDetector,
  defaultEmojiReactionMap,
  defaultReactions,
  defaultSortPreset,
  defaultTranslationFunction,
  descending,
  deviceIds$,
  disposeOfMediaStream,
  dominantSpeaker,
  getAudioBrowserPermission,
  getAudioDevices,
  getAudioOutputDevices,
  getAudioStream,
  getClientDetails,
  getDeviceState,
  getScreenShareStream,
  getSdkInfo,
  getVideoBrowserPermission,
  getVideoDevices,
  getVideoStream,
  getWebRTCInfo,
  hasAudio,
  hasPausedTrack,
  hasScreenShare,
  hasScreenShareAudio,
  hasVideo,
  humanize,
  isPinned,
  livestreamOrAudioRoomSortPreset,
  logToConsole,
  name,
  noopComparator,
  paginatedLayoutSortPreset,
  pinned,
  publishingAudio,
  publishingVideo,
  reactionType,
  resolveDeviceId,
  role,
  screenSharing,
  setDeviceInfo,
  setOSInfo,
  setPowerState,
  setSdkInfo,
  setThermalState,
  setWebRTCInfo,
  speakerLayoutSortPreset,
  speaking,
  translations,
  useBackgroundFilters,
  useCall,
  useCallStateHooks,
  useCalls,
  useConnectedUser,
  useDeviceList,
  useEffectEvent,
  useFilteredParticipants,
  useHorizontalScrollPosition,
  useI18n,
  useMenuContext,
  useModeration,
  useNoiseCancellation,
  useObservableValue,
  useParticipantViewContext,
  usePersistedDevicePreferences,
  useRequestPermission,
  useStore,
  useStreamVideoClient,
  useToggleCallRecording,
  useTrackElementVisibility,
  useVerticalScrollPosition,
  videoLoggerSystem,
  withParticipantSource
};
//# sourceMappingURL=@stream-io_video-react-sdk.js.map
